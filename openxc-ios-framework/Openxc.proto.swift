// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "openxc.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public func == (lhs: VehicleMessage, rhs: VehicleMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasCanMessage == rhs.hasCanMessage) && (!lhs.hasCanMessage || lhs.canMessage == rhs.canMessage)
  fieldCheck = fieldCheck && (lhs.hasSimpleMessage == rhs.hasSimpleMessage) && (!lhs.hasSimpleMessage || lhs.simpleMessage == rhs.simpleMessage)
  fieldCheck = fieldCheck && (lhs.hasDiagnosticResponse == rhs.hasDiagnosticResponse) && (!lhs.hasDiagnosticResponse || lhs.diagnosticResponse == rhs.diagnosticResponse)
  fieldCheck = fieldCheck && (lhs.hasControlCommand == rhs.hasControlCommand) && (!lhs.hasControlCommand || lhs.controlCommand == rhs.controlCommand)
  fieldCheck = fieldCheck && (lhs.hasCommandResponse == rhs.hasCommandResponse) && (!lhs.hasCommandResponse || lhs.commandResponse == rhs.commandResponse)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CanMessage, rhs: CanMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  fieldCheck = fieldCheck && (lhs.hasFrameFormat == rhs.hasFrameFormat) && (!lhs.hasFrameFormat || lhs.frameFormat == rhs.frameFormat)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ControlCommand, rhs: ControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasDiagnosticRequest == rhs.hasDiagnosticRequest) && (!lhs.hasDiagnosticRequest || lhs.diagnosticRequest == rhs.diagnosticRequest)
  fieldCheck = fieldCheck && (lhs.hasPassthroughModeRequest == rhs.hasPassthroughModeRequest) && (!lhs.hasPassthroughModeRequest || lhs.passthroughModeRequest == rhs.passthroughModeRequest)
  fieldCheck = fieldCheck && (lhs.hasAcceptanceFilterBypassCommand == rhs.hasAcceptanceFilterBypassCommand) && (!lhs.hasAcceptanceFilterBypassCommand || lhs.acceptanceFilterBypassCommand == rhs.acceptanceFilterBypassCommand)
  fieldCheck = fieldCheck && (lhs.hasPayloadFormatCommand == rhs.hasPayloadFormatCommand) && (!lhs.hasPayloadFormatCommand || lhs.payloadFormatCommand == rhs.payloadFormatCommand)
  fieldCheck = fieldCheck && (lhs.hasPredefinedObd2RequestsCommand == rhs.hasPredefinedObd2RequestsCommand) && (!lhs.hasPredefinedObd2RequestsCommand || lhs.predefinedObd2RequestsCommand == rhs.predefinedObd2RequestsCommand)
  fieldCheck = fieldCheck && (lhs.hasModemConfigurationCommand == rhs.hasModemConfigurationCommand) && (!lhs.hasModemConfigurationCommand || lhs.modemConfigurationCommand == rhs.modemConfigurationCommand)
  fieldCheck = fieldCheck && (lhs.hasRtcConfigurationCommand == rhs.hasRtcConfigurationCommand) && (!lhs.hasRtcConfigurationCommand || lhs.rtcConfigurationCommand == rhs.rtcConfigurationCommand)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticControlCommand, rhs: DiagnosticControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequest == rhs.hasRequest) && (!lhs.hasRequest || lhs.request == rhs.request)
  fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PassthroughModeControlCommand, rhs: PassthroughModeControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: AcceptanceFilterBypassCommand, rhs: AcceptanceFilterBypassCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasBypass == rhs.hasBypass) && (!lhs.hasBypass || lhs.bypass == rhs.bypass)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PayloadFormatCommand, rhs: PayloadFormatCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFormat == rhs.hasFormat) && (!lhs.hasFormat || lhs.format == rhs.format)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PredefinedObd2RequestsCommand, rhs: PredefinedObd2RequestsCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkOperatorSettings, rhs: NetworkOperatorSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAllowDataRoaming == rhs.hasAllowDataRoaming) && (!lhs.hasAllowDataRoaming || lhs.allowDataRoaming == rhs.allowDataRoaming)
  fieldCheck = fieldCheck && (lhs.hasOperatorSelectMode == rhs.hasOperatorSelectMode) && (!lhs.hasOperatorSelectMode || lhs.operatorSelectMode == rhs.operatorSelectMode)
  fieldCheck = fieldCheck && (lhs.hasNetworkDescriptor == rhs.hasNetworkDescriptor) && (!lhs.hasNetworkDescriptor || lhs.networkDescriptor == rhs.networkDescriptor)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkOperatorSettings.NetworkDescriptor, rhs: NetworkOperatorSettings.NetworkDescriptor) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPlmn == rhs.hasPlmn) && (!lhs.hasPlmn || lhs.plmn == rhs.plmn)
  fieldCheck = fieldCheck && (lhs.hasNetworkType == rhs.hasNetworkType) && (!lhs.hasNetworkType || lhs.networkType == rhs.networkType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkDataSettings, rhs: NetworkDataSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasApn == rhs.hasApn) && (!lhs.hasApn || lhs.apn == rhs.apn)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ServerConnectSettings, rhs: ServerConnectSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHost == rhs.hasHost) && (!lhs.hasHost || lhs.host == rhs.host)
  fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ModemConfigurationCommand, rhs: ModemConfigurationCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNetworkOperatorSettings == rhs.hasNetworkOperatorSettings) && (!lhs.hasNetworkOperatorSettings || lhs.networkOperatorSettings == rhs.networkOperatorSettings)
  fieldCheck = fieldCheck && (lhs.hasNetworkDataSettings == rhs.hasNetworkDataSettings) && (!lhs.hasNetworkDataSettings || lhs.networkDataSettings == rhs.networkDataSettings)
  fieldCheck = fieldCheck && (lhs.hasServerConnectSettings == rhs.hasServerConnectSettings) && (!lhs.hasServerConnectSettings || lhs.serverConnectSettings == rhs.serverConnectSettings)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RtcconfigurationCommand, rhs: RtcconfigurationCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnixTime == rhs.hasUnixTime) && (!lhs.hasUnixTime || lhs.unixTime == rhs.unixTime)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CommandResponse, rhs: CommandResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticRequest, rhs: DiagnosticRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasMessageId == rhs.hasMessageId) && (!lhs.hasMessageId || lhs.messageId == rhs.messageId)
  fieldCheck = fieldCheck && (lhs.hasMode == rhs.hasMode) && (!lhs.hasMode || lhs.mode == rhs.mode)
  fieldCheck = fieldCheck && (lhs.hasPid == rhs.hasPid) && (!lhs.hasPid || lhs.pid == rhs.pid)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = fieldCheck && (lhs.hasMultipleResponses == rhs.hasMultipleResponses) && (!lhs.hasMultipleResponses || lhs.multipleResponses == rhs.multipleResponses)
  fieldCheck = fieldCheck && (lhs.hasFrequency == rhs.hasFrequency) && (!lhs.hasFrequency || lhs.frequency == rhs.frequency)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasDecodedType == rhs.hasDecodedType) && (!lhs.hasDecodedType || lhs.decodedType == rhs.decodedType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticResponse, rhs: DiagnosticResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasMessageId == rhs.hasMessageId) && (!lhs.hasMessageId || lhs.messageId == rhs.messageId)
  fieldCheck = fieldCheck && (lhs.hasMode == rhs.hasMode) && (!lhs.hasMode || lhs.mode == rhs.mode)
  fieldCheck = fieldCheck && (lhs.hasPid == rhs.hasPid) && (!lhs.hasPid || lhs.pid == rhs.pid)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasNegativeResponseCode == rhs.hasNegativeResponseCode) && (!lhs.hasNegativeResponseCode || lhs.negativeResponseCode == rhs.negativeResponseCode)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DynamicField, rhs: DynamicField) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
  fieldCheck = fieldCheck && (lhs.hasNumericValue == rhs.hasNumericValue) && (!lhs.hasNumericValue || lhs.numericValue == rhs.numericValue)
  fieldCheck = fieldCheck && (lhs.hasBooleanValue == rhs.hasBooleanValue) && (!lhs.hasBooleanValue || lhs.booleanValue == rhs.booleanValue)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SimpleMessage, rhs: SimpleMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.hasEvent == rhs.hasEvent) && (!lhs.hasEvent || lhs.event == rhs.event)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct OpenxcRoot {
  public static var sharedInstance : OpenxcRoot {
   struct Static {
       static let instance : OpenxcRoot = OpenxcRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(_ registry:ExtensionRegistry) {
  }
}

final public class VehicleMessage : GeneratedMessage, GeneratedMessageProtocol {
    


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case can = 1
      case simple = 2
      case diagnostic = 3
      case controlCommand = 4
      case commandResponse = 5
      public func toString() -> String {
        switch self {
        case .can: return "CAN"
        case .simple: return "SIMPLE"
        case .diagnostic: return "DIAGNOSTIC"
        case .controlCommand: return "CONTROL_COMMAND"
        case .commandResponse: return "COMMAND_RESPONSE"
        }
      }
      public static func fromString(_ str:String) throws -> VehicleMessage.Types {
        switch str {
        case "CAN":  return .can
        case "SIMPLE":  return .simple
        case "DIAGNOSTIC":  return .diagnostic
        case "CONTROL_COMMAND":  return .controlCommand
        case "COMMAND_RESPONSE":  return .commandResponse
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .can: return ".Can"
              case .simple: return ".Simple"
              case .diagnostic: return ".Diagnostic"
              case .controlCommand: return ".ControlCommand"
              case .commandResponse: return ".CommandResponse"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var types:VehicleMessage.Types = VehicleMessage.Types.can
  public fileprivate(set) var hasTypes:Bool = false
  public fileprivate(set) var hasCanMessage:Bool = false
  public fileprivate(set) var canMessage:CanMessage!
  public fileprivate(set) var hasSimpleMessage:Bool = false
  public fileprivate(set) var simpleMessage:SimpleMessage!
  public fileprivate(set) var hasDiagnosticResponse:Bool = false
  public fileprivate(set) var diagnosticResponse:DiagnosticResponse!
  public fileprivate(set) var hasControlCommand:Bool = false
  public fileprivate(set) var controlCommand:ControlCommand!
  public fileprivate(set) var hasCommandResponse:Bool = false
  public fileprivate(set) var commandResponse:CommandResponse!
  public fileprivate(set) var hasTimestamp:Bool = false
  public fileprivate(set) var timestamp:UInt64 = UInt64(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
        try output.writeEnum(fieldNumber: 1, value:types.rawValue)
    }
    if hasCanMessage {
      try output.writeMessage(fieldNumber: 2, value:canMessage)
    }
    if hasSimpleMessage {
      try output.writeMessage(fieldNumber: 3, value:simpleMessage)
    }
    if hasDiagnosticResponse {
      try output.writeMessage(fieldNumber: 4, value:diagnosticResponse)
    }
    if hasControlCommand {
      try output.writeMessage(fieldNumber: 5, value:controlCommand)
    }
    if hasCommandResponse {
      try output.writeMessage(fieldNumber: 6, value:commandResponse)
    }
    if hasTimestamp {
      try output.writeUInt64(fieldNumber: 7, value:timestamp)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasCanMessage {
        if let varSizecanMessage = canMessage?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizecanMessage
        }
    }
    if hasSimpleMessage {
        if let varSizesimpleMessage = simpleMessage?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizesimpleMessage
        }
    }
    if hasDiagnosticResponse {
        if let varSizediagnosticResponse = diagnosticResponse?.computeMessageSize(fieldNumber: 4) {
            serialize_size += varSizediagnosticResponse
        }
    }
    if hasControlCommand {
        if let varSizecontrolCommand = controlCommand?.computeMessageSize(fieldNumber: 5) {
            serialize_size += varSizecontrolCommand
        }
    }
    if hasCommandResponse {
        if let varSizecommandResponse = commandResponse?.computeMessageSize(fieldNumber: 6) {
            serialize_size += varSizecommandResponse
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(fieldNumber: 7)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<VehicleMessage> {
    var mergedArray = Array<VehicleMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
    
    /////////////
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> VehicleMessage? {
    return try VehicleMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
    

    /////////
    
    public static func parseFrom(data: Data) throws -> Self {
        return try VehicleMessage.Builder().parseFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
    }

    public static func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try VehicleMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    
    public static func parseFrom(inputStream:InputStream) throws -> Self {
        return try VehicleMessage.Builder().mergeFromInputStream(input).build()

    }
    
    public static func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try VehicleMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()

    }
    
    public static func parseFrom(codedInputStream:CodedInputStream) throws -> Self {
        return try VehicleMessage.Builder().mergeFromCodedInputStream(input).build()
    }
    
    public static func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
    return try VehicleMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }


  
  public class func getBuilder() -> VehicleMessage.Builder {
    return VehicleMessage.classBuilder() as! VehicleMessage.Builder
  }
  public func getBuilder() -> VehicleMessage.Builder {
    return classBuilder() as! VehicleMessage.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return VehicleMessage.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return VehicleMessage.Builder()
  }
  public func toBuilder() throws -> VehicleMessage.Builder {
    return try VehicleMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:VehicleMessage) throws -> VehicleMessage.Builder {
    return try VehicleMessage.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasTypes {
      jsonMap["type"] = types.toString() as AnyObject?
    }
    if hasCanMessage {
      jsonMap["canMessage"] = try canMessage.encode() as AnyObject?
    }
    if hasSimpleMessage {
      jsonMap["simpleMessage"] = try simpleMessage.encode() as AnyObject?
    }
    if hasDiagnosticResponse {
      jsonMap["diagnosticResponse"] = try diagnosticResponse.encode() as AnyObject?
    }
    if hasControlCommand {
      jsonMap["controlCommand"] = try controlCommand.encode() as AnyObject?
    }
    if hasCommandResponse {
      jsonMap["commandResponse"] = try commandResponse.encode() as AnyObject?
    }
    if hasTimestamp {
      jsonMap["timestamp"] = "\(timestamp)" as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> VehicleMessage {
    return try VehicleMessage.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> VehicleMessage {
    return try VehicleMessage.Builder.fromJSONToBuilder(data: data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasCanMessage {
      output += "\(indent) canMessage {\n"
      if let outDescCanMessage = canMessage {
        output += try outDescCanMessage.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSimpleMessage {
      output += "\(indent) simpleMessage {\n"
      if let outDescSimpleMessage = simpleMessage {
        output += try outDescSimpleMessage.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDiagnosticResponse {
      output += "\(indent) diagnosticResponse {\n"
      if let outDescDiagnosticResponse = diagnosticResponse {
        output += try outDescDiagnosticResponse.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasControlCommand {
      output += "\(indent) controlCommand {\n"
      if let outDescControlCommand = controlCommand {
        output += try outDescControlCommand.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCommandResponse {
      output += "\(indent) commandResponse {\n"
      if let outDescCommandResponse = commandResponse {
        output += try outDescCommandResponse.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasCanMessage {
              if let hashValuecanMessage = canMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecanMessage
              }
          }
          if hasSimpleMessage {
              if let hashValuesimpleMessage = simpleMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesimpleMessage
              }
          }
          if hasDiagnosticResponse {
              if let hashValuediagnosticResponse = diagnosticResponse?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuediagnosticResponse
              }
          }
          if hasControlCommand {
              if let hashValuecontrolCommand = controlCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecontrolCommand
              }
          }
          if hasCommandResponse {
              if let hashValuecommandResponse = commandResponse?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecommandResponse
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "VehicleMessage"
  }
  override public func className() -> String {
      return "VehicleMessage"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return VehicleMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:VehicleMessage = VehicleMessage()
    public func getMessage() -> VehicleMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:VehicleMessage.Types {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:VehicleMessage.Types) -> VehicleMessage.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> VehicleMessage.Builder {
         builderResult.hasTypes = false
         builderResult.types = .can
         return self
      }
    public var hasCanMessage:Bool {
         get {
             return builderResult.hasCanMessage
         }
    }
    public var canMessage:CanMessage! {
         get {
             if canMessageBuilder_ != nil {
                builderResult.canMessage = canMessageBuilder_.getMessage()
             }
             return builderResult.canMessage
         }
         set (value) {
             builderResult.hasCanMessage = true
             builderResult.canMessage = value
         }
    }
    fileprivate var canMessageBuilder_:CanMessage.Builder! {
         didSet {
            builderResult.hasCanMessage = true
         }
    }
    public func getCanMessageBuilder() -> CanMessage.Builder {
      if canMessageBuilder_ == nil {
         canMessageBuilder_ = CanMessage.Builder()
         builderResult.canMessage = canMessageBuilder_.getMessage()
         if canMessage != nil {
            try! canMessageBuilder_.mergeFrom(canMessage)
         }
      }
      return canMessageBuilder_
    }
    public func setCanMessage(_ value:CanMessage!) -> VehicleMessage.Builder {
      self.canMessage = value
      return self
    }
    public func mergeCanMessage(_ value:CanMessage) throws -> VehicleMessage.Builder {
      if builderResult.hasCanMessage {
        builderResult.canMessage = try CanMessage.builderWithPrototype(builderResult.canMessage).mergeFrom(value).buildPartial()
      } else {
        builderResult.canMessage = value
      }
      builderResult.hasCanMessage = true
      return self
    }
    public func clearCanMessage() -> VehicleMessage.Builder {
      canMessageBuilder_ = nil
      builderResult.hasCanMessage = false
      builderResult.canMessage = nil
      return self
    }
    public var hasSimpleMessage:Bool {
         get {
             return builderResult.hasSimpleMessage
         }
    }
    public var simpleMessage:SimpleMessage! {
         get {
             if simpleMessageBuilder_ != nil {
                builderResult.simpleMessage = simpleMessageBuilder_.getMessage()
             }
             return builderResult.simpleMessage
         }
         set (value) {
             builderResult.hasSimpleMessage = true
             builderResult.simpleMessage = value
         }
    }
    fileprivate var simpleMessageBuilder_:SimpleMessage.Builder! {
         didSet {
            builderResult.hasSimpleMessage = true
         }
    }
    public func getSimpleMessageBuilder() -> SimpleMessage.Builder {
      if simpleMessageBuilder_ == nil {
         simpleMessageBuilder_ = SimpleMessage.Builder()
         builderResult.simpleMessage = simpleMessageBuilder_.getMessage()
         if simpleMessage != nil {
            try! simpleMessageBuilder_.mergeFrom(simpleMessage)
         }
      }
      return simpleMessageBuilder_
    }
    public func setSimpleMessage(_ value:SimpleMessage!) -> VehicleMessage.Builder {
      self.simpleMessage = value
      return self
    }
    public func mergeSimpleMessage(_ value:SimpleMessage) throws -> VehicleMessage.Builder {
      if builderResult.hasSimpleMessage {
        builderResult.simpleMessage = try SimpleMessage.builderWithPrototype(builderResult.simpleMessage).mergeFrom(value).buildPartial()
      } else {
        builderResult.simpleMessage = value
      }
      builderResult.hasSimpleMessage = true
      return self
    }
    public func clearSimpleMessage() -> VehicleMessage.Builder {
      simpleMessageBuilder_ = nil
      builderResult.hasSimpleMessage = false
      builderResult.simpleMessage = nil
      return self
    }
    public var hasDiagnosticResponse:Bool {
         get {
             return builderResult.hasDiagnosticResponse
         }
    }
    public var diagnosticResponse:DiagnosticResponse! {
         get {
             if diagnosticResponseBuilder_ != nil {
                builderResult.diagnosticResponse = diagnosticResponseBuilder_.getMessage()
             }
             return builderResult.diagnosticResponse
         }
         set (value) {
             builderResult.hasDiagnosticResponse = true
             builderResult.diagnosticResponse = value
         }
    }
    fileprivate var diagnosticResponseBuilder_:DiagnosticResponse.Builder! {
         didSet {
            builderResult.hasDiagnosticResponse = true
         }
    }
    public func getDiagnosticResponseBuilder() -> DiagnosticResponse.Builder {
      if diagnosticResponseBuilder_ == nil {
         diagnosticResponseBuilder_ = DiagnosticResponse.Builder()
         builderResult.diagnosticResponse = diagnosticResponseBuilder_.getMessage()
         if diagnosticResponse != nil {
            try! diagnosticResponseBuilder_.mergeFrom(diagnosticResponse)
         }
      }
      return diagnosticResponseBuilder_
    }
    public func setDiagnosticResponse(_ value:DiagnosticResponse!) -> VehicleMessage.Builder {
      self.diagnosticResponse = value
      return self
    }
    public func mergeDiagnosticResponse(_ value:DiagnosticResponse) throws -> VehicleMessage.Builder {
      if builderResult.hasDiagnosticResponse {
        builderResult.diagnosticResponse = try DiagnosticResponse.builderWithPrototype(builderResult.diagnosticResponse).mergeFrom(value).buildPartial()
      } else {
        builderResult.diagnosticResponse = value
      }
      builderResult.hasDiagnosticResponse = true
      return self
    }
    public func clearDiagnosticResponse() -> VehicleMessage.Builder {
      diagnosticResponseBuilder_ = nil
      builderResult.hasDiagnosticResponse = false
      builderResult.diagnosticResponse = nil
      return self
    }
    public var hasControlCommand:Bool {
         get {
             return builderResult.hasControlCommand
         }
    }
    public var controlCommand:ControlCommand! {
         get {
             if controlCommandBuilder_ != nil {
                builderResult.controlCommand = controlCommandBuilder_.getMessage()
             }
             return builderResult.controlCommand
         }
         set (value) {
             builderResult.hasControlCommand = true
             builderResult.controlCommand = value
         }
    }
    fileprivate var controlCommandBuilder_:ControlCommand.Builder! {
         didSet {
            builderResult.hasControlCommand = true
         }
    }
    public func getControlCommandBuilder() -> ControlCommand.Builder {
      if controlCommandBuilder_ == nil {
         controlCommandBuilder_ = ControlCommand.Builder()
         builderResult.controlCommand = controlCommandBuilder_.getMessage()
         if controlCommand != nil {
            try! controlCommandBuilder_.mergeFrom(controlCommand)
         }
      }
      return controlCommandBuilder_
    }
    public func setControlCommand(_ value:ControlCommand!) -> VehicleMessage.Builder {
      self.controlCommand = value
      return self
    }
    public func mergeControlCommand(_ value:ControlCommand) throws -> VehicleMessage.Builder {
      if builderResult.hasControlCommand {
        builderResult.controlCommand = try ControlCommand.builderWithPrototype(builderResult.controlCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.controlCommand = value
      }
      builderResult.hasControlCommand = true
      return self
    }
    public func clearControlCommand() -> VehicleMessage.Builder {
      controlCommandBuilder_ = nil
      builderResult.hasControlCommand = false
      builderResult.controlCommand = nil
      return self
    }
    public var hasCommandResponse:Bool {
         get {
             return builderResult.hasCommandResponse
         }
    }
    public var commandResponse:CommandResponse! {
         get {
             if commandResponseBuilder_ != nil {
                builderResult.commandResponse = commandResponseBuilder_.getMessage()
             }
             return builderResult.commandResponse
         }
         set (value) {
             builderResult.hasCommandResponse = true
             builderResult.commandResponse = value
         }
    }
    fileprivate var commandResponseBuilder_:CommandResponse.Builder! {
         didSet {
            builderResult.hasCommandResponse = true
         }
    }
    public func getCommandResponseBuilder() -> CommandResponse.Builder {
      if commandResponseBuilder_ == nil {
         commandResponseBuilder_ = CommandResponse.Builder()
         builderResult.commandResponse = commandResponseBuilder_.getMessage()
         if commandResponse != nil {
            try! commandResponseBuilder_.mergeFrom(commandResponse)
         }
      }
      return commandResponseBuilder_
    }
    public func setCommandResponse(_ value:CommandResponse!) -> VehicleMessage.Builder {
      self.commandResponse = value
      return self
    }
    public func mergeCommandResponse(_ value:CommandResponse) throws -> VehicleMessage.Builder {
      if builderResult.hasCommandResponse {
        builderResult.commandResponse = try CommandResponse.builderWithPrototype(builderResult.commandResponse).mergeFrom(value).buildPartial()
      } else {
        builderResult.commandResponse = value
      }
      builderResult.hasCommandResponse = true
      return self
    }
    public func clearCommandResponse() -> VehicleMessage.Builder {
      commandResponseBuilder_ = nil
      builderResult.hasCommandResponse = false
      builderResult.commandResponse = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> VehicleMessage.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> VehicleMessage.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> VehicleMessage.Builder {
      builderResult = VehicleMessage()
      return self
    }
    override public func clone() throws -> VehicleMessage.Builder {
      return try VehicleMessage.builderWithPrototype(builderResult)
    }
    override public func build() throws -> VehicleMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> VehicleMessage {
      let returnMe:VehicleMessage = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:VehicleMessage) throws -> VehicleMessage.Builder {
      if other == VehicleMessage() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if (other.hasCanMessage) {
          try _ = mergeCanMessage(other.canMessage)
      }
      if (other.hasSimpleMessage) {
          try _ = mergeSimpleMessage(other.simpleMessage)
      }
      if (other.hasDiagnosticResponse) {
          try _ = mergeDiagnosticResponse(other.diagnosticResponse)
      }
      if (other.hasControlCommand) {
          try _ = mergeControlCommand(other.controlCommand)
      }
      if (other.hasCommandResponse) {
          try _ = mergeCommandResponse(other.commandResponse)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
//      try mergeUnknownFields(other.unknownFields)
        try merge(unknownField: other.unknownFields)
    return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> VehicleMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VehicleMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = VehicleMessage.Types(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttypes))
          }

        case 18:
          let subBuilder:CanMessage.Builder = CanMessage.Builder()
          if hasCanMessage {
            try _ = subBuilder.mergeFrom(canMessage)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          canMessage = subBuilder.buildPartial()

        case 26:
          let subBuilder:SimpleMessage.Builder = SimpleMessage.Builder()
          if hasSimpleMessage {
            try _ = subBuilder.mergeFrom(simpleMessage)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          simpleMessage = subBuilder.buildPartial()

        case 34:
          let subBuilder:DiagnosticResponse.Builder = DiagnosticResponse.Builder()
          if hasDiagnosticResponse {
            try _ = subBuilder.mergeFrom(diagnosticResponse)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          diagnosticResponse = subBuilder.buildPartial()

        case 42:
          let subBuilder:ControlCommand.Builder = ControlCommand.Builder()
          if hasControlCommand {
            try _ = subBuilder.mergeFrom(controlCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          controlCommand = subBuilder.buildPartial()

        case 50:
          let subBuilder:CommandResponse.Builder = CommandResponse.Builder()
          if hasCommandResponse {
            try _ = subBuilder.mergeFrom(commandResponse)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          commandResponse = subBuilder.buildPartial()

        case 56:
          timestamp = try input.readUInt64()

        default:
            if (!(try parse(codedInputStream: input, unknownFields: unknownFieldsBuilder, extensionRegistry: extensionRegistry, tag: protobufTag)) {
                unknownFields = try unknownFieldsBuilder.build()
                return self
}
/*          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> VehicleMessage.Builder {
      let resultDecodedBuilder = VehicleMessage.Builder()
      if let jsonValueTypes = jsonMap["type"] as? String {
        resultDecodedBuilder.types = try VehicleMessage.Types.fromString(jsonValueTypes)
      }
      if let jsonValueCanMessage = jsonMap["canMessage"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.canMessage = try CanMessage.Builder.decodeToBuilder(jsonValueCanMessage).build()

      }
      if let jsonValueSimpleMessage = jsonMap["simpleMessage"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.simpleMessage = try SimpleMessage.Builder.decodeToBuilder(jsonValueSimpleMessage).build()

      }
      if let jsonValueDiagnosticResponse = jsonMap["diagnosticResponse"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.diagnosticResponse = try DiagnosticResponse.Builder.decodeToBuilder(jsonValueDiagnosticResponse).build()

      }
      if let jsonValueControlCommand = jsonMap["controlCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.controlCommand = try ControlCommand.Builder.decodeToBuilder(jsonValueControlCommand).build()

      }
      if let jsonValueCommandResponse = jsonMap["commandResponse"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.commandResponse = try CommandResponse.Builder.decodeToBuilder(jsonValueCommandResponse).build()

      }
      if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
        resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> VehicleMessage.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try VehicleMessage.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class CanMessage : GeneratedMessage, GeneratedMessageProtocol {
    public static func parseFrom(codedInputStream: CodedInputStream, extensionRegistry: ExtensionRegistry) throws -> Self {
        
    }




    //Enum type declaration start 

    public enum FrameFormat:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case standard = 1
      case extended = 2
      public func toString() -> String {
        switch self {
        case .standard: return "STANDARD"
        case .extended: return "EXTENDED"
        }
      }
      public static func fromString(_ str:String) throws -> CanMessage.FrameFormat {
        switch str {
        case "STANDARD":  return .standard
        case "EXTENDED":  return .extended
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .standard: return ".Standard"
              case .extended: return ".Extended"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasId:Bool = false
  public fileprivate(set) var id:UInt32 = UInt32(0)

  public fileprivate(set) var hasData:Bool = false
  public fileprivate(set) var data:Data = Data()

  public fileprivate(set) var frameFormat:CanMessage.FrameFormat = CanMessage.FrameFormat.standard
  public fileprivate(set) var hasFrameFormat:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBus {
      try output.writeInt32(fieldNumber: 1, value:bus)
    }
    if hasId {
      try output.writeUInt32(fieldNumber:2, value:id)
    }
    if hasData {
      try output.writeData(fieldNumber:3, value:data)
    }
    if hasFrameFormat {
      try output.writeEnum(fieldNumber:4, value:frameFormat.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber:1)
    }
    if hasId {
      serialize_size += id.computeUInt32Size(fieldNumber:2)
    }
    if hasData {
      serialize_size += data.computeDataSize(fieldNumber:3)
    }
    if (hasFrameFormat) {
      serialize_size += frameFormat.rawValue.computeEnumSize(fieldNumber:4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<CanMessage> {
    var mergedArray = Array<CanMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }

    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> CanMessage? {
        return try CanMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    
    public static func parseFrom(inputStream: InputStream, extensionRegistry: ExtensionRegistry) throws -> Self {
        return try CanMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    
    public static func parseFrom(data: Data, extensionRegistry: ExtensionRegistry) throws -> Self {
        return try CanMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    
    public static func parseFrom(codedInputStream: CodedInputStream) throws -> Self {
        return try CanMessage.Builder().mergeFromCodedInputStream(input).build()
    }
    
    public static func parseFrom(inputStream: InputStream) throws -> Self {
        return try CanMessage.Builder().mergeFromInputStream(input).build()
    }
    
    public static func parseFrom(data: Data) throws -> Self {
        return try CanMessage.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
    }

    
  public class func getBuilder() -> CanMessage.Builder {
    return CanMessage.classBuilder() as! CanMessage.Builder
  }
  public func getBuilder() -> CanMessage.Builder {
    return classBuilder() as! CanMessage.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return CanMessage.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return CanMessage.Builder()
  }
  public func toBuilder() throws -> CanMessage.Builder {
    return try CanMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:CanMessage) throws -> CanMessage.Builder {
    return try CanMessage.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBus {
      jsonMap["bus"] = NSNumber(value: bus as Int32)
    }
    if hasId {
      jsonMap["id"] = NSNumber(value: id as UInt32)
    }
    if hasData {
      jsonMap["data"] = data.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0)) as AnyObject?
    }
    if hasFrameFormat {
      jsonMap["frameFormat"] = frameFormat.toString() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> CanMessage {
    return try CanMessage.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> CanMessage {
    return try CanMessage.Builder.fromJSONToBuilder(data: data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    if (hasFrameFormat) {
      output += "\(indent) frameFormat: \(frameFormat.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          if hasFrameFormat {
             hashCode = (hashCode &* 31) &+ Int(frameFormat.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CanMessage"
  }
  override public func className() -> String {
      return "CanMessage"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return CanMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:CanMessage = CanMessage()
    public func getMessage() -> CanMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> CanMessage.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> CanMessage.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:UInt32 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(_ value:UInt32) -> CanMessage.Builder {
      self.id = value
      return self
    }
    public func clearId() -> CanMessage.Builder{
         builderResult.hasId = false
         builderResult.id = UInt32(0)
         return self
    }
    public var hasData:Bool {
         get {
              return builderResult.hasData
         }
    }
    public var data:Data {
         get {
              return builderResult.data
         }
         set (value) {
             builderResult.hasData = true
             builderResult.data = value
         }
    }
    public func setData(_ value:Data) -> CanMessage.Builder {
      self.data = value
      return self
    }
    public func clearData() -> CanMessage.Builder{
         builderResult.hasData = false
         builderResult.data = Data()
         return self
    }
      public var hasFrameFormat:Bool{
          get {
              return builderResult.hasFrameFormat
          }
      }
      public var frameFormat:CanMessage.FrameFormat {
          get {
              return builderResult.frameFormat
          }
          set (value) {
              builderResult.hasFrameFormat = true
              builderResult.frameFormat = value
          }
      }
      public func setFrameFormat(_ value:CanMessage.FrameFormat) -> CanMessage.Builder {
        self.frameFormat = value
        return self
      }
      public func clearFrameFormat() -> CanMessage.Builder {
         builderResult.hasFrameFormat = false
         builderResult.frameFormat = .standard
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> CanMessage.Builder {
      builderResult = CanMessage()
      return self
    }
    override public func clone() throws -> CanMessage.Builder {
      return try CanMessage.builderWithPrototype(builderResult)
    }
    override public func build() throws -> CanMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CanMessage {
      let returnMe:CanMessage = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:CanMessage) throws -> CanMessage.Builder {
      if other == CanMessage() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasId {
           id = other.id
      }
      if other.hasData {
           data = other.data
      }
      if other.hasFrameFormat {
           frameFormat = other.frameFormat
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> CanMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CanMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try input.readInt32()

        case 16:
          id = try input.readUInt32()

        case 26:
          data = try input.readData()

        case 32:
          let valueIntframeFormat = try input.readEnum()
          if let enumsframeFormat = CanMessage.FrameFormat(rawValue:valueIntframeFormat){
               frameFormat = enumsframeFormat
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntframeFormat))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> CanMessage.Builder {
      let resultDecodedBuilder = CanMessage.Builder()
      if let jsonValueBus = jsonMap["bus"] as? NSNumber {
        resultDecodedBuilder.bus = Int32(jsonValueBus.intValue)
      }
      if let jsonValueId = jsonMap["id"] as? NSNumber {
        resultDecodedBuilder.id = jsonValueId.uint32Value
      }
      if let jsonValueData = jsonMap["data"] as? String {
        resultDecodedBuilder.data = Data(base64EncodedString:jsonValueData, options: NSData.Base64DecodingOptions(rawValue:0))!
      }
      if let jsonValueFrameFormat = jsonMap["frameFormat"] as? String {
        resultDecodedBuilder.frameFormat = try CanMessage.FrameFormat.fromString(jsonValueFrameFormat)
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> CanMessage.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try CanMessage.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class ControlCommand : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case version = 1
      case deviceId = 2
      case diagnostic = 3
      case passthrough = 4
      case acceptanceFilterBypass = 5
      case payloadFormat = 6
      case predefinedObd2Requests = 7
      case modemConfiguration = 8
      case rtcConfiguration = 9
      case sdMountStatus = 10
      case platform = 11
      public func toString() -> String {
        switch self {
        case .version: return "VERSION"
        case .deviceId: return "DEVICE_ID"
        case .diagnostic: return "DIAGNOSTIC"
        case .passthrough: return "PASSTHROUGH"
        case .acceptanceFilterBypass: return "ACCEPTANCE_FILTER_BYPASS"
        case .payloadFormat: return "PAYLOAD_FORMAT"
        case .predefinedObd2Requests: return "PREDEFINED_OBD2_REQUESTS"
        case .modemConfiguration: return "MODEM_CONFIGURATION"
        case .rtcConfiguration: return "RTC_CONFIGURATION"
        case .sdMountStatus: return "SD_MOUNT_STATUS"
        case .platform: return "PLATFORM"
        }
      }
      public static func fromString(_ str:String) throws -> ControlCommand.Types {
        switch str {
        case "VERSION":  return .version
        case "DEVICE_ID":  return .deviceId
        case "DIAGNOSTIC":  return .diagnostic
        case "PASSTHROUGH":  return .passthrough
        case "ACCEPTANCE_FILTER_BYPASS":  return .acceptanceFilterBypass
        case "PAYLOAD_FORMAT":  return .payloadFormat
        case "PREDEFINED_OBD2_REQUESTS":  return .predefinedObd2Requests
        case "MODEM_CONFIGURATION":  return .modemConfiguration
        case "RTC_CONFIGURATION":  return .rtcConfiguration
        case "SD_MOUNT_STATUS":  return .sdMountStatus
        case "PLATFORM":  return .platform
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .version: return ".Version"
              case .deviceId: return ".DeviceId"
              case .diagnostic: return ".Diagnostic"
              case .passthrough: return ".Passthrough"
              case .acceptanceFilterBypass: return ".AcceptanceFilterBypass"
              case .payloadFormat: return ".PayloadFormat"
              case .predefinedObd2Requests: return ".PredefinedObd2Requests"
              case .modemConfiguration: return ".ModemConfiguration"
              case .rtcConfiguration: return ".RtcConfiguration"
              case .sdMountStatus: return ".SdMountStatus"
              case .platform: return ".Platform"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var types:ControlCommand.Types = ControlCommand.Types.version
  public fileprivate(set) var hasTypes:Bool = false
  public fileprivate(set) var hasDiagnosticRequest:Bool = false
  public fileprivate(set) var diagnosticRequest:DiagnosticControlCommand!
  public fileprivate(set) var hasPassthroughModeRequest:Bool = false
  public fileprivate(set) var passthroughModeRequest:PassthroughModeControlCommand!
  public fileprivate(set) var hasAcceptanceFilterBypassCommand:Bool = false
  public fileprivate(set) var acceptanceFilterBypassCommand:AcceptanceFilterBypassCommand!
  public fileprivate(set) var hasPayloadFormatCommand:Bool = false
  public fileprivate(set) var payloadFormatCommand:PayloadFormatCommand!
  public fileprivate(set) var hasPredefinedObd2RequestsCommand:Bool = false
  public fileprivate(set) var predefinedObd2RequestsCommand:PredefinedObd2RequestsCommand!
  public fileprivate(set) var hasModemConfigurationCommand:Bool = false
  public fileprivate(set) var modemConfigurationCommand:ModemConfigurationCommand!
  public fileprivate(set) var hasRtcConfigurationCommand:Bool = false
  public fileprivate(set) var rtcConfigurationCommand:RtcconfigurationCommand!
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(fieldNumber: 1, value:types.rawValue)
    }
    if hasDiagnosticRequest {
      try output.writeMessage(fieldNumber: 2, value:diagnosticRequest)
    }
    if hasPassthroughModeRequest {
      try output.writeMessage(fieldNumber: 3, value:passthroughModeRequest)
    }
    if hasAcceptanceFilterBypassCommand {
      try output.writeMessage(fieldNumber: 4, value:acceptanceFilterBypassCommand)
    }
    if hasPayloadFormatCommand {
      try output.writeMessage(fieldNumber: 5, value:payloadFormatCommand)
    }
    if hasPredefinedObd2RequestsCommand {
      try output.writeMessage(fieldNumber: 6, value:predefinedObd2RequestsCommand)
    }
    if hasModemConfigurationCommand {
      try output.writeMessage(fieldNumber: 7, value:modemConfigurationCommand)
    }
    if hasRtcConfigurationCommand {
      try output.writeMessage(fieldNumber: 8, value:rtcConfigurationCommand)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasDiagnosticRequest {
        if let varSizediagnosticRequest = diagnosticRequest?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizediagnosticRequest
        }
    }
    if hasPassthroughModeRequest {
        if let varSizepassthroughModeRequest = passthroughModeRequest?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizepassthroughModeRequest
        }
    }
    if hasAcceptanceFilterBypassCommand {
        if let varSizeacceptanceFilterBypassCommand = acceptanceFilterBypassCommand?.computeMessageSize(fieldNumber: 4) {
            serialize_size += varSizeacceptanceFilterBypassCommand
        }
    }
    if hasPayloadFormatCommand {
        if let varSizepayloadFormatCommand = payloadFormatCommand?.computeMessageSize(fieldNumber: 5) {
            serialize_size += varSizepayloadFormatCommand
        }
    }
    if hasPredefinedObd2RequestsCommand {
        if let varSizepredefinedObd2RequestsCommand = predefinedObd2RequestsCommand?.computeMessageSize(fieldNumber: 6) {
            serialize_size += varSizepredefinedObd2RequestsCommand
        }
    }
    if hasModemConfigurationCommand {
        if let varSizemodemConfigurationCommand = modemConfigurationCommand?.computeMessageSize(fieldNumber: 7) {
            serialize_size += varSizemodemConfigurationCommand
        }
    }
    if hasRtcConfigurationCommand {
        if let varSizertcConfigurationCommand = rtcConfigurationCommand?.computeMessageSize(fieldNumber: 8) {
            serialize_size += varSizertcConfigurationCommand
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<ControlCommand> {
    var mergedArray = Array<ControlCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> ControlCommand? {
    return try ControlCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
   
    public static func parseFrom(data: Data) throws -> Self {
            return try ControlCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
    }
    
    public static func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try ControlCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()

    }
    public static func parseFrom(inputStream:InputStream) throws -> Self {
        return try ControlCommand.Builder().mergeFromInputStream(input).build()

    }
    public static func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try ControlCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()

    }
    public static func parseFrom(codedInputStream:CodedInputStream) throws -> Self {
        return try ControlCommand.Builder().mergeFromCodedInputStream(input).build()

    }
    public static func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try ControlCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()

    }

    
    
  public class func getBuilder() -> ControlCommand.Builder {
    return ControlCommand.classBuilder() as! ControlCommand.Builder
  }
  public func getBuilder() -> ControlCommand.Builder {
    return classBuilder() as! ControlCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return ControlCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return ControlCommand.Builder()
  }
  public func toBuilder() throws -> ControlCommand.Builder {
    return try ControlCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ControlCommand) throws -> ControlCommand.Builder {
    return try ControlCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasTypes {
      jsonMap["type"] = types.toString() as AnyObject?
    }
    if hasDiagnosticRequest {
      jsonMap["diagnosticRequest"] = try diagnosticRequest.encode() as AnyObject?
    }
    if hasPassthroughModeRequest {
      jsonMap["passthroughModeRequest"] = try passthroughModeRequest.encode() as AnyObject?
    }
    if hasAcceptanceFilterBypassCommand {
      jsonMap["acceptanceFilterBypassCommand"] = try acceptanceFilterBypassCommand.encode() as AnyObject?
    }
    if hasPayloadFormatCommand {
      jsonMap["payloadFormatCommand"] = try payloadFormatCommand.encode() as AnyObject?
    }
    if hasPredefinedObd2RequestsCommand {
      jsonMap["predefinedObd2RequestsCommand"] = try predefinedObd2RequestsCommand.encode() as AnyObject?
    }
    if hasModemConfigurationCommand {
      jsonMap["modemConfigurationCommand"] = try modemConfigurationCommand.encode() as AnyObject?
    }
    if hasRtcConfigurationCommand {
      jsonMap["rtcConfigurationCommand"] = try rtcConfigurationCommand.encode() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> ControlCommand {
    return try ControlCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> ControlCommand {
    return try ControlCommand.Builder.fromJSONToBuilder(data: data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasDiagnosticRequest {
      output += "\(indent) diagnosticRequest {\n"
      if let outDescDiagnosticRequest = diagnosticRequest {
        output += try outDescDiagnosticRequest.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPassthroughModeRequest {
      output += "\(indent) passthroughModeRequest {\n"
      if let outDescPassthroughModeRequest = passthroughModeRequest {
        output += try outDescPassthroughModeRequest.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasAcceptanceFilterBypassCommand {
      output += "\(indent) acceptanceFilterBypassCommand {\n"
      if let outDescAcceptanceFilterBypassCommand = acceptanceFilterBypassCommand {
        output += try outDescAcceptanceFilterBypassCommand.getDescription(indent: "\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPayloadFormatCommand {
      output += "\(indent) payloadFormatCommand {\n"
      if let outDescPayloadFormatCommand = payloadFormatCommand {
        output += try outDescPayloadFormatCommand.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPredefinedObd2RequestsCommand {
      output += "\(indent) predefinedObd2RequestsCommand {\n"
      if let outDescPredefinedObd2RequestsCommand = predefinedObd2RequestsCommand {
        output += try outDescPredefinedObd2RequestsCommand.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasModemConfigurationCommand {
      output += "\(indent) modemConfigurationCommand {\n"
      if let outDescModemConfigurationCommand = modemConfigurationCommand {
        output += try outDescModemConfigurationCommand.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasRtcConfigurationCommand {
      output += "\(indent) rtcConfigurationCommand {\n"
      if let outDescRtcConfigurationCommand = rtcConfigurationCommand {
        output += try outDescRtcConfigurationCommand.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasDiagnosticRequest {
              if let hashValuediagnosticRequest = diagnosticRequest?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuediagnosticRequest
              }
          }
          if hasPassthroughModeRequest {
              if let hashValuepassthroughModeRequest = passthroughModeRequest?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepassthroughModeRequest
              }
          }
          if hasAcceptanceFilterBypassCommand {
              if let hashValueacceptanceFilterBypassCommand = acceptanceFilterBypassCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueacceptanceFilterBypassCommand
              }
          }
          if hasPayloadFormatCommand {
              if let hashValuepayloadFormatCommand = payloadFormatCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepayloadFormatCommand
              }
          }
          if hasPredefinedObd2RequestsCommand {
              if let hashValuepredefinedObd2RequestsCommand = predefinedObd2RequestsCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepredefinedObd2RequestsCommand
              }
          }
          if hasModemConfigurationCommand {
              if let hashValuemodemConfigurationCommand = modemConfigurationCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemodemConfigurationCommand
              }
          }
          if hasRtcConfigurationCommand {
              if let hashValuertcConfigurationCommand = rtcConfigurationCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuertcConfigurationCommand
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ControlCommand"
  }
  override public func className() -> String {
      return "ControlCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return ControlCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:ControlCommand = ControlCommand()
    public func getMessage() -> ControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ControlCommand.Types {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ControlCommand.Types) -> ControlCommand.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> ControlCommand.Builder {
         builderResult.hasTypes = false
         builderResult.types = .version
         return self
      }
    public var hasDiagnosticRequest:Bool {
         get {
             return builderResult.hasDiagnosticRequest
         }
    }
    public var diagnosticRequest:DiagnosticControlCommand! {
         get {
             if diagnosticRequestBuilder_ != nil {
                builderResult.diagnosticRequest = diagnosticRequestBuilder_.getMessage()
             }
             return builderResult.diagnosticRequest
         }
         set (value) {
             builderResult.hasDiagnosticRequest = true
             builderResult.diagnosticRequest = value
         }
    }
    fileprivate var diagnosticRequestBuilder_:DiagnosticControlCommand.Builder! {
         didSet {
            builderResult.hasDiagnosticRequest = true
         }
    }
    public func getDiagnosticRequestBuilder() -> DiagnosticControlCommand.Builder {
      if diagnosticRequestBuilder_ == nil {
         diagnosticRequestBuilder_ = DiagnosticControlCommand.Builder()
         builderResult.diagnosticRequest = diagnosticRequestBuilder_.getMessage()
         if diagnosticRequest != nil {
            try! diagnosticRequestBuilder_.mergeFrom(diagnosticRequest)
         }
      }
      return diagnosticRequestBuilder_
    }
    public func setDiagnosticRequest(_ value:DiagnosticControlCommand!) -> ControlCommand.Builder {
      self.diagnosticRequest = value
      return self
    }
    public func mergeDiagnosticRequest(_ value:DiagnosticControlCommand) throws -> ControlCommand.Builder {
      if builderResult.hasDiagnosticRequest {
        builderResult.diagnosticRequest = try DiagnosticControlCommand.builderWithPrototype(builderResult.diagnosticRequest).mergeFrom(value).buildPartial()
      } else {
        builderResult.diagnosticRequest = value
      }
      builderResult.hasDiagnosticRequest = true
      return self
    }
    public func clearDiagnosticRequest() -> ControlCommand.Builder {
      diagnosticRequestBuilder_ = nil
      builderResult.hasDiagnosticRequest = false
      builderResult.diagnosticRequest = nil
      return self
    }
    public var hasPassthroughModeRequest:Bool {
         get {
             return builderResult.hasPassthroughModeRequest
         }
    }
    public var passthroughModeRequest:PassthroughModeControlCommand! {
         get {
             if passthroughModeRequestBuilder_ != nil {
                builderResult.passthroughModeRequest = passthroughModeRequestBuilder_.getMessage()
             }
             return builderResult.passthroughModeRequest
         }
         set (value) {
             builderResult.hasPassthroughModeRequest = true
             builderResult.passthroughModeRequest = value
         }
    }
    fileprivate var passthroughModeRequestBuilder_:PassthroughModeControlCommand.Builder! {
         didSet {
            builderResult.hasPassthroughModeRequest = true
         }
    }
    public func getPassthroughModeRequestBuilder() -> PassthroughModeControlCommand.Builder {
      if passthroughModeRequestBuilder_ == nil {
         passthroughModeRequestBuilder_ = PassthroughModeControlCommand.Builder()
         builderResult.passthroughModeRequest = passthroughModeRequestBuilder_.getMessage()
         if passthroughModeRequest != nil {
            try! passthroughModeRequestBuilder_.mergeFrom(passthroughModeRequest)
         }
      }
      return passthroughModeRequestBuilder_
    }
    public func setPassthroughModeRequest(_ value:PassthroughModeControlCommand!) -> ControlCommand.Builder {
      self.passthroughModeRequest = value
      return self
    }
    public func mergePassthroughModeRequest(_ value:PassthroughModeControlCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPassthroughModeRequest {
        builderResult.passthroughModeRequest = try PassthroughModeControlCommand.builderWithPrototype(builderResult.passthroughModeRequest).mergeFrom(value).buildPartial()
      } else {
        builderResult.passthroughModeRequest = value
      }
      builderResult.hasPassthroughModeRequest = true
      return self
    }
    public func clearPassthroughModeRequest() -> ControlCommand.Builder {
      passthroughModeRequestBuilder_ = nil
      builderResult.hasPassthroughModeRequest = false
      builderResult.passthroughModeRequest = nil
      return self
    }
    public var hasAcceptanceFilterBypassCommand:Bool {
         get {
             return builderResult.hasAcceptanceFilterBypassCommand
         }
    }
    public var acceptanceFilterBypassCommand:AcceptanceFilterBypassCommand! {
         get {
             if acceptanceFilterBypassCommandBuilder_ != nil {
                builderResult.acceptanceFilterBypassCommand = acceptanceFilterBypassCommandBuilder_.getMessage()
             }
             return builderResult.acceptanceFilterBypassCommand
         }
         set (value) {
             builderResult.hasAcceptanceFilterBypassCommand = true
             builderResult.acceptanceFilterBypassCommand = value
         }
    }
    fileprivate var acceptanceFilterBypassCommandBuilder_:AcceptanceFilterBypassCommand.Builder! {
         didSet {
            builderResult.hasAcceptanceFilterBypassCommand = true
         }
    }
    public func getAcceptanceFilterBypassCommandBuilder() -> AcceptanceFilterBypassCommand.Builder {
      if acceptanceFilterBypassCommandBuilder_ == nil {
         acceptanceFilterBypassCommandBuilder_ = AcceptanceFilterBypassCommand.Builder()
         builderResult.acceptanceFilterBypassCommand = acceptanceFilterBypassCommandBuilder_.getMessage()
         if acceptanceFilterBypassCommand != nil {
            try! acceptanceFilterBypassCommandBuilder_.mergeFrom(acceptanceFilterBypassCommand)
         }
      }
      return acceptanceFilterBypassCommandBuilder_
    }
    public func setAcceptanceFilterBypassCommand(_ value:AcceptanceFilterBypassCommand!) -> ControlCommand.Builder {
      self.acceptanceFilterBypassCommand = value
      return self
    }
    public func mergeAcceptanceFilterBypassCommand(_ value:AcceptanceFilterBypassCommand) throws -> ControlCommand.Builder {
      if builderResult.hasAcceptanceFilterBypassCommand {
        builderResult.acceptanceFilterBypassCommand = try AcceptanceFilterBypassCommand.builderWithPrototype(builderResult.acceptanceFilterBypassCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.acceptanceFilterBypassCommand = value
      }
      builderResult.hasAcceptanceFilterBypassCommand = true
      return self
    }
    public func clearAcceptanceFilterBypassCommand() -> ControlCommand.Builder {
      acceptanceFilterBypassCommandBuilder_ = nil
      builderResult.hasAcceptanceFilterBypassCommand = false
      builderResult.acceptanceFilterBypassCommand = nil
      return self
    }
    public var hasPayloadFormatCommand:Bool {
         get {
             return builderResult.hasPayloadFormatCommand
         }
    }
    public var payloadFormatCommand:PayloadFormatCommand! {
         get {
             if payloadFormatCommandBuilder_ != nil {
                builderResult.payloadFormatCommand = payloadFormatCommandBuilder_.getMessage()
             }
             return builderResult.payloadFormatCommand
         }
         set (value) {
             builderResult.hasPayloadFormatCommand = true
             builderResult.payloadFormatCommand = value
         }
    }
    fileprivate var payloadFormatCommandBuilder_:PayloadFormatCommand.Builder! {
         didSet {
            builderResult.hasPayloadFormatCommand = true
         }
    }
    public func getPayloadFormatCommandBuilder() -> PayloadFormatCommand.Builder {
      if payloadFormatCommandBuilder_ == nil {
         payloadFormatCommandBuilder_ = PayloadFormatCommand.Builder()
         builderResult.payloadFormatCommand = payloadFormatCommandBuilder_.getMessage()
         if payloadFormatCommand != nil {
            try! payloadFormatCommandBuilder_.mergeFrom(payloadFormatCommand)
         }
      }
      return payloadFormatCommandBuilder_
    }
    public func setPayloadFormatCommand(_ value:PayloadFormatCommand!) -> ControlCommand.Builder {
      self.payloadFormatCommand = value
      return self
    }
    public func mergePayloadFormatCommand(_ value:PayloadFormatCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPayloadFormatCommand {
        builderResult.payloadFormatCommand = try PayloadFormatCommand.builderWithPrototype(builderResult.payloadFormatCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.payloadFormatCommand = value
      }
      builderResult.hasPayloadFormatCommand = true
      return self
    }
    public func clearPayloadFormatCommand() -> ControlCommand.Builder {
      payloadFormatCommandBuilder_ = nil
      builderResult.hasPayloadFormatCommand = false
      builderResult.payloadFormatCommand = nil
      return self
    }
    public var hasPredefinedObd2RequestsCommand:Bool {
         get {
             return builderResult.hasPredefinedObd2RequestsCommand
         }
    }
    public var predefinedObd2RequestsCommand:PredefinedObd2RequestsCommand! {
         get {
             if predefinedObd2RequestsCommandBuilder_ != nil {
                builderResult.predefinedObd2RequestsCommand = predefinedObd2RequestsCommandBuilder_.getMessage()
             }
             return builderResult.predefinedObd2RequestsCommand
         }
         set (value) {
             builderResult.hasPredefinedObd2RequestsCommand = true
             builderResult.predefinedObd2RequestsCommand = value
         }
    }
    fileprivate var predefinedObd2RequestsCommandBuilder_:PredefinedObd2RequestsCommand.Builder! {
         didSet {
            builderResult.hasPredefinedObd2RequestsCommand = true
         }
    }
    public func getPredefinedObd2RequestsCommandBuilder() -> PredefinedObd2RequestsCommand.Builder {
      if predefinedObd2RequestsCommandBuilder_ == nil {
         predefinedObd2RequestsCommandBuilder_ = PredefinedObd2RequestsCommand.Builder()
         builderResult.predefinedObd2RequestsCommand = predefinedObd2RequestsCommandBuilder_.getMessage()
         if predefinedObd2RequestsCommand != nil {
            try! predefinedObd2RequestsCommandBuilder_.mergeFrom(predefinedObd2RequestsCommand)
         }
      }
      return predefinedObd2RequestsCommandBuilder_
    }
    public func setPredefinedObd2RequestsCommand(_ value:PredefinedObd2RequestsCommand!) -> ControlCommand.Builder {
      self.predefinedObd2RequestsCommand = value
      return self
    }
    public func mergePredefinedObd2RequestsCommand(_ value:PredefinedObd2RequestsCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPredefinedObd2RequestsCommand {
        builderResult.predefinedObd2RequestsCommand = try PredefinedObd2RequestsCommand.builderWithPrototype(builderResult.predefinedObd2RequestsCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.predefinedObd2RequestsCommand = value
      }
      builderResult.hasPredefinedObd2RequestsCommand = true
      return self
    }
    public func clearPredefinedObd2RequestsCommand() -> ControlCommand.Builder {
      predefinedObd2RequestsCommandBuilder_ = nil
      builderResult.hasPredefinedObd2RequestsCommand = false
      builderResult.predefinedObd2RequestsCommand = nil
      return self
    }
    public var hasModemConfigurationCommand:Bool {
         get {
             return builderResult.hasModemConfigurationCommand
         }
    }
    public var modemConfigurationCommand:ModemConfigurationCommand! {
         get {
             if modemConfigurationCommandBuilder_ != nil {
                builderResult.modemConfigurationCommand = modemConfigurationCommandBuilder_.getMessage()
             }
             return builderResult.modemConfigurationCommand
         }
         set (value) {
             builderResult.hasModemConfigurationCommand = true
             builderResult.modemConfigurationCommand = value
         }
    }
    fileprivate var modemConfigurationCommandBuilder_:ModemConfigurationCommand.Builder! {
         didSet {
            builderResult.hasModemConfigurationCommand = true
         }
    }
    public func getModemConfigurationCommandBuilder() -> ModemConfigurationCommand.Builder {
      if modemConfigurationCommandBuilder_ == nil {
         modemConfigurationCommandBuilder_ = ModemConfigurationCommand.Builder()
         builderResult.modemConfigurationCommand = modemConfigurationCommandBuilder_.getMessage()
         if modemConfigurationCommand != nil {
            try! modemConfigurationCommandBuilder_.mergeFrom(modemConfigurationCommand)
         }
      }
      return modemConfigurationCommandBuilder_
    }
    public func setModemConfigurationCommand(_ value:ModemConfigurationCommand!) -> ControlCommand.Builder {
      self.modemConfigurationCommand = value
      return self
    }
    public func mergeModemConfigurationCommand(_ value:ModemConfigurationCommand) throws -> ControlCommand.Builder {
      if builderResult.hasModemConfigurationCommand {
        builderResult.modemConfigurationCommand = try ModemConfigurationCommand.builderWithPrototype(builderResult.modemConfigurationCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.modemConfigurationCommand = value
      }
      builderResult.hasModemConfigurationCommand = true
      return self
    }
    public func clearModemConfigurationCommand() -> ControlCommand.Builder {
      modemConfigurationCommandBuilder_ = nil
      builderResult.hasModemConfigurationCommand = false
      builderResult.modemConfigurationCommand = nil
      return self
    }
    public var hasRtcConfigurationCommand:Bool {
         get {
             return builderResult.hasRtcConfigurationCommand
         }
    }
    public var rtcConfigurationCommand:RtcconfigurationCommand! {
         get {
             if rtcConfigurationCommandBuilder_ != nil {
                builderResult.rtcConfigurationCommand = rtcConfigurationCommandBuilder_.getMessage()
             }
             return builderResult.rtcConfigurationCommand
         }
         set (value) {
             builderResult.hasRtcConfigurationCommand = true
             builderResult.rtcConfigurationCommand = value
         }
    }
    fileprivate var rtcConfigurationCommandBuilder_:RtcconfigurationCommand.Builder! {
         didSet {
            builderResult.hasRtcConfigurationCommand = true
         }
    }
    public func getRtcConfigurationCommandBuilder() -> RtcconfigurationCommand.Builder {
      if rtcConfigurationCommandBuilder_ == nil {
         rtcConfigurationCommandBuilder_ = RtcconfigurationCommand.Builder()
         builderResult.rtcConfigurationCommand = rtcConfigurationCommandBuilder_.getMessage()
         if rtcConfigurationCommand != nil {
            try! rtcConfigurationCommandBuilder_.mergeFrom(rtcConfigurationCommand)
         }
      }
      return rtcConfigurationCommandBuilder_
    }
    public func setRtcConfigurationCommand(_ value:RtcconfigurationCommand!) -> ControlCommand.Builder {
      self.rtcConfigurationCommand = value
      return self
    }
    public func mergeRtcConfigurationCommand(_ value:RtcconfigurationCommand) throws -> ControlCommand.Builder {
      if builderResult.hasRtcConfigurationCommand {
        builderResult.rtcConfigurationCommand = try RtcconfigurationCommand.builderWithPrototype(builderResult.rtcConfigurationCommand).mergeFrom(value).buildPartial()
      } else {
        builderResult.rtcConfigurationCommand = value
      }
      builderResult.hasRtcConfigurationCommand = true
      return self
    }
    public func clearRtcConfigurationCommand() -> ControlCommand.Builder {
      rtcConfigurationCommandBuilder_ = nil
      builderResult.hasRtcConfigurationCommand = false
      builderResult.rtcConfigurationCommand = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> ControlCommand.Builder {
      builderResult = ControlCommand()
      return self
    }
    override public func clone() throws -> ControlCommand.Builder {
      return try ControlCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> ControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ControlCommand {
      let returnMe:ControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ControlCommand) throws -> ControlCommand.Builder {
      if other == ControlCommand() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if (other.hasDiagnosticRequest) {
          try mergeDiagnosticRequest(other.diagnosticRequest)
      }
      if (other.hasPassthroughModeRequest) {
          try mergePassthroughModeRequest(other.passthroughModeRequest)
      }
      if (other.hasAcceptanceFilterBypassCommand) {
          try mergeAcceptanceFilterBypassCommand(other.acceptanceFilterBypassCommand)
      }
      if (other.hasPayloadFormatCommand) {
          try mergePayloadFormatCommand(other.payloadFormatCommand)
      }
      if (other.hasPredefinedObd2RequestsCommand) {
          try mergePredefinedObd2RequestsCommand(other.predefinedObd2RequestsCommand)
      }
      if (other.hasModemConfigurationCommand) {
          try mergeModemConfigurationCommand(other.modemConfigurationCommand)
      }
      if (other.hasRtcConfigurationCommand) {
          try mergeRtcConfigurationCommand(other.rtcConfigurationCommand)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ControlCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ControlCommand.Types(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttypes))
          }

        case 18:
          let subBuilder:DiagnosticControlCommand.Builder = DiagnosticControlCommand.Builder()
          if hasDiagnosticRequest {
            try subBuilder.mergeFrom(diagnosticRequest)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          diagnosticRequest = subBuilder.buildPartial()

        case 26:
          let subBuilder:PassthroughModeControlCommand.Builder = PassthroughModeControlCommand.Builder()
          if hasPassthroughModeRequest {
            try subBuilder.mergeFrom(passthroughModeRequest)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          passthroughModeRequest = subBuilder.buildPartial()

        case 34:
          let subBuilder:AcceptanceFilterBypassCommand.Builder = AcceptanceFilterBypassCommand.Builder()
          if hasAcceptanceFilterBypassCommand {
            try subBuilder.mergeFrom(acceptanceFilterBypassCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          acceptanceFilterBypassCommand = subBuilder.buildPartial()

        case 42:
          let subBuilder:PayloadFormatCommand.Builder = PayloadFormatCommand.Builder()
          if hasPayloadFormatCommand {
            try subBuilder.mergeFrom(payloadFormatCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          payloadFormatCommand = subBuilder.buildPartial()

        case 50:
          let subBuilder:PredefinedObd2RequestsCommand.Builder = PredefinedObd2RequestsCommand.Builder()
          if hasPredefinedObd2RequestsCommand {
            try subBuilder.mergeFrom(predefinedObd2RequestsCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          predefinedObd2RequestsCommand = subBuilder.buildPartial()

        case 58:
          let subBuilder:ModemConfigurationCommand.Builder = ModemConfigurationCommand.Builder()
          if hasModemConfigurationCommand {
            try subBuilder.mergeFrom(modemConfigurationCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          modemConfigurationCommand = subBuilder.buildPartial()

        case 66:
          let subBuilder:RtcconfigurationCommand.Builder = RtcconfigurationCommand.Builder()
          if hasRtcConfigurationCommand {
            try subBuilder.mergeFrom(rtcConfigurationCommand)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          rtcConfigurationCommand = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> ControlCommand.Builder {
      let resultDecodedBuilder = ControlCommand.Builder()
      if let jsonValueTypes = jsonMap["type"] as? String {
        resultDecodedBuilder.types = try ControlCommand.Types.fromString(jsonValueTypes)
      }
      if let jsonValueDiagnosticRequest = jsonMap["diagnosticRequest"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.diagnosticRequest = try DiagnosticControlCommand.Builder.decodeToBuilder(jsonValueDiagnosticRequest).build()

      }
      if let jsonValuePassthroughModeRequest = jsonMap["passthroughModeRequest"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.passthroughModeRequest = try PassthroughModeControlCommand.Builder.decodeToBuilder(jsonValuePassthroughModeRequest).build()

      }
      if let jsonValueAcceptanceFilterBypassCommand = jsonMap["acceptanceFilterBypassCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.acceptanceFilterBypassCommand = try AcceptanceFilterBypassCommand.Builder.decodeToBuilder(jsonValueAcceptanceFilterBypassCommand).build()

      }
      if let jsonValuePayloadFormatCommand = jsonMap["payloadFormatCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.payloadFormatCommand = try PayloadFormatCommand.Builder.decodeToBuilder(jsonValuePayloadFormatCommand).build()

      }
      if let jsonValuePredefinedObd2RequestsCommand = jsonMap["predefinedObd2RequestsCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.predefinedObd2RequestsCommand = try PredefinedObd2RequestsCommand.Builder.decodeToBuilder(jsonValuePredefinedObd2RequestsCommand).build()

      }
      if let jsonValueModemConfigurationCommand = jsonMap["modemConfigurationCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.modemConfigurationCommand = try ModemConfigurationCommand.Builder.decodeToBuilder(jsonValueModemConfigurationCommand).build()

      }
      if let jsonValueRtcConfigurationCommand = jsonMap["rtcConfigurationCommand"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.rtcConfigurationCommand = try RtcconfigurationCommand.Builder.decodeToBuilder(jsonValueRtcConfigurationCommand).build()

      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> ControlCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try ControlCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class DiagnosticControlCommand : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum Action:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case add = 1
      case cancel = 2
      public func toString() -> String {
        switch self {
        case .add: return "ADD"
        case .cancel: return "CANCEL"
        }
      }
      public static func fromString(_ str:String) throws -> DiagnosticControlCommand.Action {
        switch str {
        case "ADD":  return .add
        case "CANCEL":  return .cancel
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .add: return ".Add"
              case .cancel: return ".Cancel"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var hasRequest:Bool = false
  public fileprivate(set) var request:DiagnosticRequest!
  public fileprivate(set) var action:DiagnosticControlCommand.Action = DiagnosticControlCommand.Action.add
  public fileprivate(set) var hasAction:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasRequest {
        try output.writeMessage(fieldNumber:1, value:request)
    }
    if hasAction {
        try output.writeEnum(fieldNumber: 2, value:action.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequest {
        if let varSizerequest = request?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizerequest
        }
    }
    if (hasAction) {
        serialize_size += action.rawValue.computeEnumSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<DiagnosticControlCommand> {
    var mergedArray = Array<DiagnosticControlCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> DiagnosticControlCommand? {
    return try DiagnosticControlCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
   
    public static func parseFrom(data: Data) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
    }
    
    public static func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    
    public static func parseFrom(inputStream:InputStream) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromInputStream(input).build()
    }
    
    public static func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    
    public static func parseFrom(codedInputStream:CodedInputStream) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromCodedInputStream(input).build()
    }
    public static func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Self {
        return try DiagnosticControlCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }

    
    
  public class func getBuilder() -> DiagnosticControlCommand.Builder {
    return DiagnosticControlCommand.classBuilder() as! DiagnosticControlCommand.Builder
  }
  public func getBuilder() -> DiagnosticControlCommand.Builder {
    return classBuilder() as! DiagnosticControlCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return DiagnosticControlCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return DiagnosticControlCommand.Builder()
  }
  public func toBuilder() throws -> DiagnosticControlCommand.Builder {
    return try DiagnosticControlCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DiagnosticControlCommand) throws -> DiagnosticControlCommand.Builder {
    return try DiagnosticControlCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasRequest {
      jsonMap["request"] = try request.encode() as AnyObject?
    }
    if hasAction {
      jsonMap["action"] = action.toString() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder.fromJSONToBuilder(data: data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasRequest {
      output += "\(indent) request {\n"
      if let outDescRequest = request {
        output += try outDescRequest.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasAction) {
      output += "\(indent) action: \(action.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequest {
              if let hashValuerequest = request?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequest
              }
          }
          if hasAction {
             hashCode = (hashCode &* 31) &+ Int(action.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticControlCommand"
  }
  override public func className() -> String {
      return "DiagnosticControlCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return DiagnosticControlCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:DiagnosticControlCommand = DiagnosticControlCommand()
    public func getMessage() -> DiagnosticControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequest:Bool {
         get {
             return builderResult.hasRequest
         }
    }
    public var request:DiagnosticRequest! {
         get {
             if requestBuilder_ != nil {
                builderResult.request = requestBuilder_.getMessage()
             }
             return builderResult.request
         }
         set (value) {
             builderResult.hasRequest = true
             builderResult.request = value
         }
    }
    fileprivate var requestBuilder_:DiagnosticRequest.Builder! {
         didSet {
            builderResult.hasRequest = true
         }
    }
    public func getRequestBuilder() -> DiagnosticRequest.Builder {
      if requestBuilder_ == nil {
         requestBuilder_ = DiagnosticRequest.Builder()
         builderResult.request = requestBuilder_.getMessage()
         if request != nil {
            try! requestBuilder_.mergeFrom(request)
         }
      }
      return requestBuilder_
    }
    public func setRequest(_ value:DiagnosticRequest!) -> DiagnosticControlCommand.Builder {
      self.request = value
      return self
    }
    public func mergeRequest(_ value:DiagnosticRequest) throws -> DiagnosticControlCommand.Builder {
      if builderResult.hasRequest {
        builderResult.request = try DiagnosticRequest.builderWithPrototype(builderResult.request).mergeFrom(value).buildPartial()
      } else {
        builderResult.request = value
      }
      builderResult.hasRequest = true
      return self
    }
    public func clearRequest() -> DiagnosticControlCommand.Builder {
      requestBuilder_ = nil
      builderResult.hasRequest = false
      builderResult.request = nil
      return self
    }
      public var hasAction:Bool{
          get {
              return builderResult.hasAction
          }
      }
      public var action:DiagnosticControlCommand.Action {
          get {
              return builderResult.action
          }
          set (value) {
              builderResult.hasAction = true
              builderResult.action = value
          }
      }
      public func setAction(_ value:DiagnosticControlCommand.Action) -> DiagnosticControlCommand.Builder {
        self.action = value
        return self
      }
      public func clearAction() -> DiagnosticControlCommand.Builder {
         builderResult.hasAction = false
         builderResult.action = .add
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> DiagnosticControlCommand.Builder {
      builderResult = DiagnosticControlCommand()
      return self
    }
    override public func clone() throws -> DiagnosticControlCommand.Builder {
      return try DiagnosticControlCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> DiagnosticControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticControlCommand {
      let returnMe:DiagnosticControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DiagnosticControlCommand) throws -> DiagnosticControlCommand.Builder {
      if other == DiagnosticControlCommand() {
       return self
      }
      if (other.hasRequest) {
          try mergeRequest(other.request)
      }
      if other.hasAction {
           action = other.action
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DiagnosticControlCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:DiagnosticRequest.Builder = DiagnosticRequest.Builder()
          if hasRequest {
            try subBuilder.mergeFrom(request)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          request = subBuilder.buildPartial()

        case 16:
          let valueIntaction = try input.readEnum()
          if let enumsaction = DiagnosticControlCommand.Action(rawValue:valueIntaction){
               action = enumsaction
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntaction))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticControlCommand.Builder {
      let resultDecodedBuilder = DiagnosticControlCommand.Builder()
      if let jsonValueRequest = jsonMap["request"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.request = try DiagnosticRequest.Builder.decodeToBuilder(jsonValueRequest).build()

      }
      if let jsonValueAction = jsonMap["action"] as? String {
        resultDecodedBuilder.action = try DiagnosticControlCommand.Action.fromString(jsonValueAction)
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> DiagnosticControlCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try DiagnosticControlCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class PassthroughModeControlCommand : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasEnabled:Bool = false
  public fileprivate(set) var enabled:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBus {
      try output.writeInt32(fieldNumber: 1, value:bus)
    }
    if hasEnabled {
      try output.writeBool(fieldNumber: 2, value:enabled)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasEnabled {
      serialize_size += enabled.computeBoolSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<PassthroughModeControlCommand> {
    var mergedArray = Array<PassthroughModeControlCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> PassthroughModeControlCommand? {
    return try PassthroughModeControlCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PassthroughModeControlCommand.Builder {
    return PassthroughModeControlCommand.classBuilder() as! PassthroughModeControlCommand.Builder
  }
  public func getBuilder() -> PassthroughModeControlCommand.Builder {
    return classBuilder() as! PassthroughModeControlCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return PassthroughModeControlCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return PassthroughModeControlCommand.Builder()
  }
  public func toBuilder() throws -> PassthroughModeControlCommand.Builder {
    return try PassthroughModeControlCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PassthroughModeControlCommand) throws -> PassthroughModeControlCommand.Builder {
    return try PassthroughModeControlCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBus {
      jsonMap["bus"] = NSNumber(value: bus as Int32)
    }
    if hasEnabled {
      jsonMap["enabled"] = enabled as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder.fromJSONToBuilder(data: data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasEnabled {
      output += "\(indent) enabled: \(enabled) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasEnabled {
             hashCode = (hashCode &* 31) &+ enabled.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PassthroughModeControlCommand"
  }
  override public func className() -> String {
      return "PassthroughModeControlCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return PassthroughModeControlCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:PassthroughModeControlCommand = PassthroughModeControlCommand()
    public func getMessage() -> PassthroughModeControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> PassthroughModeControlCommand.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> PassthroughModeControlCommand.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasEnabled:Bool {
         get {
              return builderResult.hasEnabled
         }
    }
    public var enabled:Bool {
         get {
              return builderResult.enabled
         }
         set (value) {
             builderResult.hasEnabled = true
             builderResult.enabled = value
         }
    }
    public func setEnabled(_ value:Bool) -> PassthroughModeControlCommand.Builder {
      self.enabled = value
      return self
    }
    public func clearEnabled() -> PassthroughModeControlCommand.Builder{
         builderResult.hasEnabled = false
         builderResult.enabled = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PassthroughModeControlCommand.Builder {
      builderResult = PassthroughModeControlCommand()
      return self
    }
    override public func clone() throws -> PassthroughModeControlCommand.Builder {
      return try PassthroughModeControlCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> PassthroughModeControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PassthroughModeControlCommand {
      let returnMe:PassthroughModeControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PassthroughModeControlCommand) throws -> PassthroughModeControlCommand.Builder {
      if other == PassthroughModeControlCommand() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasEnabled {
           enabled = other.enabled
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PassthroughModeControlCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try input.readInt32()

        case 16:
          enabled = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> PassthroughModeControlCommand.Builder {
      let resultDecodedBuilder = PassthroughModeControlCommand.Builder()
      if let jsonValueBus = jsonMap["bus"] as? NSNumber {
        resultDecodedBuilder.bus = Int32(jsonValueBus.intValue)
      }
      if let jsonValueEnabled = jsonMap["enabled"] as? Bool {
        resultDecodedBuilder.enabled = jsonValueEnabled
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> PassthroughModeControlCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PassthroughModeControlCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class AcceptanceFilterBypassCommand : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBypass:Bool = false
  public fileprivate(set) var bypass:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBus {
      try output.writeInt32(fieldNumber: 1, value:bus)
    }
    if hasBypass {
      try output.writeBool(fieldNumber: 2, value:bypass)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasBypass {
      serialize_size += bypass.computeBoolSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<AcceptanceFilterBypassCommand> {
    var mergedArray = Array<AcceptanceFilterBypassCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> AcceptanceFilterBypassCommand? {
    return try AcceptanceFilterBypassCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> AcceptanceFilterBypassCommand.Builder {
    return AcceptanceFilterBypassCommand.classBuilder() as! AcceptanceFilterBypassCommand.Builder
  }
  public func getBuilder() -> AcceptanceFilterBypassCommand.Builder {
    return classBuilder() as! AcceptanceFilterBypassCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return AcceptanceFilterBypassCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return AcceptanceFilterBypassCommand.Builder()
  }
  public func toBuilder() throws -> AcceptanceFilterBypassCommand.Builder {
    return try AcceptanceFilterBypassCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:AcceptanceFilterBypassCommand) throws -> AcceptanceFilterBypassCommand.Builder {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBus {
      jsonMap["bus"] = NSNumber(value: bus as Int32)
    }
    if hasBypass {
      jsonMap["bypass"] = bypass as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder.fromJSONToBuilder(data: data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasBypass {
      output += "\(indent) bypass: \(bypass) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasBypass {
             hashCode = (hashCode &* 31) &+ bypass.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "AcceptanceFilterBypassCommand"
  }
  override public func className() -> String {
      return "AcceptanceFilterBypassCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return AcceptanceFilterBypassCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:AcceptanceFilterBypassCommand = AcceptanceFilterBypassCommand()
    public func getMessage() -> AcceptanceFilterBypassCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> AcceptanceFilterBypassCommand.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> AcceptanceFilterBypassCommand.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasBypass:Bool {
         get {
              return builderResult.hasBypass
         }
    }
    public var bypass:Bool {
         get {
              return builderResult.bypass
         }
         set (value) {
             builderResult.hasBypass = true
             builderResult.bypass = value
         }
    }
    public func setBypass(_ value:Bool) -> AcceptanceFilterBypassCommand.Builder {
      self.bypass = value
      return self
    }
    public func clearBypass() -> AcceptanceFilterBypassCommand.Builder{
         builderResult.hasBypass = false
         builderResult.bypass = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> AcceptanceFilterBypassCommand.Builder {
      builderResult = AcceptanceFilterBypassCommand()
      return self
    }
    override public func clone() throws -> AcceptanceFilterBypassCommand.Builder {
      return try AcceptanceFilterBypassCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> AcceptanceFilterBypassCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> AcceptanceFilterBypassCommand {
      let returnMe:AcceptanceFilterBypassCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:AcceptanceFilterBypassCommand) throws -> AcceptanceFilterBypassCommand.Builder {
      if other == AcceptanceFilterBypassCommand() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasBypass {
           bypass = other.bypass
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> AcceptanceFilterBypassCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try input.readInt32()

        case 16:
          bypass = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> AcceptanceFilterBypassCommand.Builder {
      let resultDecodedBuilder = AcceptanceFilterBypassCommand.Builder()
      if let jsonValueBus = jsonMap["bus"] as? NSNumber {
        resultDecodedBuilder.bus = Int32(jsonValueBus.intValue)
      }
      if let jsonValueBypass = jsonMap["bypass"] as? Bool {
        resultDecodedBuilder.bypass = jsonValueBypass
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> AcceptanceFilterBypassCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try AcceptanceFilterBypassCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class PayloadFormatCommand : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum PayloadFormat:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case json = 1
      case protobuf = 2
      case messagepack = 3
      public func toString() -> String {
        switch self {
        case .json: return "JSON"
        case .protobuf: return "PROTOBUF"
        case .messagepack: return "MESSAGEPACK"
        }
      }
      public static func fromString(_ str:String) throws -> PayloadFormatCommand.PayloadFormat {
        switch str {
        case "JSON":  return .json
        case "PROTOBUF":  return .protobuf
        case "MESSAGEPACK":  return .messagepack
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .json: return ".Json"
              case .protobuf: return ".Protobuf"
              case .messagepack: return ".Messagepack"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var format:PayloadFormatCommand.PayloadFormat = PayloadFormatCommand.PayloadFormat.json
  public fileprivate(set) var hasFormat:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasFormat {
      try output.writeEnum(fieldNumber: 1, value:format.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasFormat) {
      serialize_size += format.rawValue.computeEnumSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<PayloadFormatCommand> {
    var mergedArray = Array<PayloadFormatCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> PayloadFormatCommand? {
    return try PayloadFormatCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PayloadFormatCommand.Builder {
    return PayloadFormatCommand.classBuilder() as! PayloadFormatCommand.Builder
  }
  public func getBuilder() -> PayloadFormatCommand.Builder {
    return classBuilder() as! PayloadFormatCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return PayloadFormatCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return PayloadFormatCommand.Builder()
  }
  public func toBuilder() throws -> PayloadFormatCommand.Builder {
    return try PayloadFormatCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PayloadFormatCommand) throws -> PayloadFormatCommand.Builder {
    return try PayloadFormatCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasFormat {
      jsonMap["format"] = format.toString() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if (hasFormat) {
      output += "\(indent) format: \(format.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFormat {
             hashCode = (hashCode &* 31) &+ Int(format.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PayloadFormatCommand"
  }
  override public func className() -> String {
      return "PayloadFormatCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return PayloadFormatCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:PayloadFormatCommand = PayloadFormatCommand()
    public func getMessage() -> PayloadFormatCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasFormat:Bool{
          get {
              return builderResult.hasFormat
          }
      }
      public var format:PayloadFormatCommand.PayloadFormat {
          get {
              return builderResult.format
          }
          set (value) {
              builderResult.hasFormat = true
              builderResult.format = value
          }
      }
      public func setFormat(_ value:PayloadFormatCommand.PayloadFormat) -> PayloadFormatCommand.Builder {
        self.format = value
        return self
      }
      public func clearFormat() -> PayloadFormatCommand.Builder {
         builderResult.hasFormat = false
         builderResult.format = .json
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PayloadFormatCommand.Builder {
      builderResult = PayloadFormatCommand()
      return self
    }
    override public func clone() throws -> PayloadFormatCommand.Builder {
      return try PayloadFormatCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> PayloadFormatCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PayloadFormatCommand {
      let returnMe:PayloadFormatCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PayloadFormatCommand) throws -> PayloadFormatCommand.Builder {
      if other == PayloadFormatCommand() {
       return self
      }
      if other.hasFormat {
           format = other.format
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PayloadFormatCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntformat = try input.readEnum()
          if let enumsformat = PayloadFormatCommand.PayloadFormat(rawValue:valueIntformat){
               format = enumsformat
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntformat))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> PayloadFormatCommand.Builder {
      let resultDecodedBuilder = PayloadFormatCommand.Builder()
      if let jsonValueFormat = jsonMap["format"] as? String {
        resultDecodedBuilder.format = try PayloadFormatCommand.PayloadFormat.fromString(jsonValueFormat)
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> PayloadFormatCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PayloadFormatCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class PredefinedObd2RequestsCommand : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasEnabled:Bool = false
  public fileprivate(set) var enabled:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasEnabled {
      try output.writeBool(fieldNumber: 1, value:enabled)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEnabled {
      serialize_size += enabled.computeBoolSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<PredefinedObd2RequestsCommand> {
    var mergedArray = Array<PredefinedObd2RequestsCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> PredefinedObd2RequestsCommand? {
    return try PredefinedObd2RequestsCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PredefinedObd2RequestsCommand.Builder {
    return PredefinedObd2RequestsCommand.classBuilder() as! PredefinedObd2RequestsCommand.Builder
  }
  public func getBuilder() -> PredefinedObd2RequestsCommand.Builder {
    return classBuilder() as! PredefinedObd2RequestsCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return PredefinedObd2RequestsCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return PredefinedObd2RequestsCommand.Builder()
  }
  public func toBuilder() throws -> PredefinedObd2RequestsCommand.Builder {
    return try PredefinedObd2RequestsCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:PredefinedObd2RequestsCommand) throws -> PredefinedObd2RequestsCommand.Builder {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasEnabled {
      jsonMap["enabled"] = enabled as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasEnabled {
      output += "\(indent) enabled: \(enabled) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEnabled {
             hashCode = (hashCode &* 31) &+ enabled.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PredefinedObd2RequestsCommand"
  }
  override public func className() -> String {
      return "PredefinedObd2RequestsCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return PredefinedObd2RequestsCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:PredefinedObd2RequestsCommand = PredefinedObd2RequestsCommand()
    public func getMessage() -> PredefinedObd2RequestsCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEnabled:Bool {
         get {
              return builderResult.hasEnabled
         }
    }
    public var enabled:Bool {
         get {
              return builderResult.enabled
         }
         set (value) {
             builderResult.hasEnabled = true
             builderResult.enabled = value
         }
    }
    public func setEnabled(_ value:Bool) -> PredefinedObd2RequestsCommand.Builder {
      self.enabled = value
      return self
    }
    public func clearEnabled() -> PredefinedObd2RequestsCommand.Builder{
         builderResult.hasEnabled = false
         builderResult.enabled = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> PredefinedObd2RequestsCommand.Builder {
      builderResult = PredefinedObd2RequestsCommand()
      return self
    }
    override public func clone() throws -> PredefinedObd2RequestsCommand.Builder {
      return try PredefinedObd2RequestsCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> PredefinedObd2RequestsCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PredefinedObd2RequestsCommand {
      let returnMe:PredefinedObd2RequestsCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:PredefinedObd2RequestsCommand) throws -> PredefinedObd2RequestsCommand.Builder {
      if other == PredefinedObd2RequestsCommand() {
       return self
      }
      if other.hasEnabled {
           enabled = other.enabled
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> PredefinedObd2RequestsCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          enabled = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> PredefinedObd2RequestsCommand.Builder {
      let resultDecodedBuilder = PredefinedObd2RequestsCommand.Builder()
      if let jsonValueEnabled = jsonMap["enabled"] as? Bool {
        resultDecodedBuilder.enabled = jsonValueEnabled
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> PredefinedObd2RequestsCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try PredefinedObd2RequestsCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class NetworkOperatorSettings : GeneratedMessage, GeneratedMessageProtocol {


  //Nested type declaration start

    final public class NetworkDescriptor : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum NetworkType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case gsm = 0
          case utran = 2
          public func toString() -> String {
            switch self {
            case .gsm: return "GSM"
            case .utran: return "UTRAN"
            }
          }
          public static func fromString(_ str:String) throws -> NetworkOperatorSettings.NetworkDescriptor.NetworkType {
            switch str {
            case "GSM":  return .gsm
            case "UTRAN":  return .utran
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
          }
          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          fileprivate func getDescription() -> String { 
              switch self {
                  case .gsm: return ".Gsm"
                  case .utran: return ".Utran"
              }
          }
        }

        //Enum type declaration end 

      public fileprivate(set) var hasPlmn:Bool = false
      public fileprivate(set) var plmn:UInt32 = UInt32(0)

      public fileprivate(set) var networkType:NetworkOperatorSettings.NetworkDescriptor.NetworkType = NetworkOperatorSettings.NetworkDescriptor.NetworkType.gsm
      public fileprivate(set) var hasNetworkType:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
        if hasPlmn {
          try output.writeUInt32(fieldNumber: 1, value:plmn)
        }
        if hasNetworkType {
          try output.writeEnum(fieldNumber: 2, value:networkType.rawValue)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPlmn {
          serialize_size += plmn.computeUInt32Size(fieldNumber: 1)
        }
        if (hasNetworkType) {
          serialize_size += networkType.rawValue.computeEnumSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<NetworkOperatorSettings.NetworkDescriptor> {
        var mergedArray = Array<NetworkOperatorSettings.NetworkDescriptor>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> NetworkOperatorSettings.NetworkDescriptor? {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(_ data:Data) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(_ input:InputStream) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return NetworkOperatorSettings.NetworkDescriptor.classBuilder() as! NetworkOperatorSettings.NetworkDescriptor.Builder
      }
      public func getBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return classBuilder() as! NetworkOperatorSettings.NetworkDescriptor.Builder
      }
      public class func classBuilder() -> MessageBuilder {
        return NetworkOperatorSettings.NetworkDescriptor.Builder()
      }
      public func classBuilder() -> MessageBuilder {
        return NetworkOperatorSettings.NetworkDescriptor.Builder()
      }
      public func toBuilder() throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(self)
      }
      public class func builderWithPrototype(_ prototype:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(prototype)
      }
      public func encode() throws -> Dictionary<String,AnyObject> {
        guard isInitialized() else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
        if hasPlmn {
          jsonMap["pLMN"] = NSNumber(value: plmn as UInt32)
        }
        if hasNetworkType {
          jsonMap["networkType"] = networkType.toString() as AnyObject?
        }
        return jsonMap
      }
      class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder.decodeToBuilder(jsonMap).build()
      }
      class public func fromJSON(_ data:Data) throws -> NetworkOperatorSettings.NetworkDescriptor {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder.fromJSONToBuilder(data).build()
      }
      public func getDescription(_ indent:String) throws -> String {
        var output = ""
        if hasPlmn {
          output += "\(indent) plmn: \(plmn) \n"
        }
        if (hasNetworkType) {
          output += "\(indent) networkType: \(networkType.description)\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPlmn {
                 hashCode = (hashCode &* 31) &+ plmn.hashValue
              }
              if hasNetworkType {
                 hashCode = (hashCode &* 31) &+ Int(networkType.rawValue)
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "NetworkOperatorSettings.NetworkDescriptor"
      }
      override public func className() -> String {
          return "NetworkOperatorSettings.NetworkDescriptor"
      }
      public func classMetaType() -> GeneratedMessage.Type {
          return NetworkOperatorSettings.NetworkDescriptor.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:NetworkOperatorSettings.NetworkDescriptor = NetworkOperatorSettings.NetworkDescriptor()
        public func getMessage() -> NetworkOperatorSettings.NetworkDescriptor {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPlmn:Bool {
             get {
                  return builderResult.hasPlmn
             }
        }
        public var plmn:UInt32 {
             get {
                  return builderResult.plmn
             }
             set (value) {
                 builderResult.hasPlmn = true
                 builderResult.plmn = value
             }
        }
        public func setPlmn(_ value:UInt32) -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          self.plmn = value
          return self
        }
        public func clearPlmn() -> NetworkOperatorSettings.NetworkDescriptor.Builder{
             builderResult.hasPlmn = false
             builderResult.plmn = UInt32(0)
             return self
        }
          public var hasNetworkType:Bool{
              get {
                  return builderResult.hasNetworkType
              }
          }
          public var networkType:NetworkOperatorSettings.NetworkDescriptor.NetworkType {
              get {
                  return builderResult.networkType
              }
              set (value) {
                  builderResult.hasNetworkType = true
                  builderResult.networkType = value
              }
          }
          public func setNetworkType(_ value:NetworkOperatorSettings.NetworkDescriptor.NetworkType) -> NetworkOperatorSettings.NetworkDescriptor.Builder {
            self.networkType = value
            return self
          }
          public func clearNetworkType() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
             builderResult.hasNetworkType = false
             builderResult.networkType = .gsm
             return self
          }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        override public func clear() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          builderResult = NetworkOperatorSettings.NetworkDescriptor()
          return self
        }
        override public func clone() throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          return try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(builderResult)
        }
        override public func build() throws -> NetworkOperatorSettings.NetworkDescriptor {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> NetworkOperatorSettings.NetworkDescriptor {
          let returnMe:NetworkOperatorSettings.NetworkDescriptor = builderResult
          return returnMe
        }
        public func mergeFrom(_ other:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          if other == NetworkOperatorSettings.NetworkDescriptor() {
           return self
          }
          if other.hasPlmn {
               plmn = other.plmn
          }
          if other.hasNetworkType {
               networkType = other.networkType
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8:
              plmn = try input.readUInt32()

            case 16:
              let valueIntnetworkType = try input.readEnum()
              if let enumsnetworkType = NetworkOperatorSettings.NetworkDescriptor.NetworkType(rawValue:valueIntnetworkType){
                   networkType = enumsnetworkType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntnetworkType))
              }

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
        class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          let resultDecodedBuilder = NetworkOperatorSettings.NetworkDescriptor.Builder()
          if let jsonValuePlmn = jsonMap["pLMN"] as? NSNumber {
            resultDecodedBuilder.plmn = jsonValuePlmn.uint32Value
          }
          if let jsonValueNetworkType = jsonMap["networkType"] as? String {
            resultDecodedBuilder.networkType = try NetworkOperatorSettings.NetworkDescriptor.NetworkType.fromString(jsonValueNetworkType)
          }
          return resultDecodedBuilder
        }
        class public func fromJSONToBuilder(_ data:Data) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
          guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
          }
          return try NetworkOperatorSettings.NetworkDescriptor.Builder.decodeToBuilder(jsDataCast)
        }
      }

    }

  //Nested type declaration end



    //Enum type declaration start 

    public enum OperatorSelectMode:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case automatic = 0
      case manual = 1
      case deregister = 2
      case setOnly = 3
      case manualAutomatic = 4
      public func toString() -> String {
        switch self {
        case .automatic: return "AUTOMATIC"
        case .manual: return "MANUAL"
        case .deregister: return "DEREGISTER"
        case .setOnly: return "SET_ONLY"
        case .manualAutomatic: return "MANUAL_AUTOMATIC"
        }
      }
      public static func fromString(_ str:String) throws -> NetworkOperatorSettings.OperatorSelectMode {
        switch str {
        case "AUTOMATIC":  return .automatic
        case "MANUAL":  return .manual
        case "DEREGISTER":  return .deregister
        case "SET_ONLY":  return .setOnly
        case "MANUAL_AUTOMATIC":  return .manualAutomatic
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .automatic: return ".Automatic"
              case .manual: return ".Manual"
              case .deregister: return ".Deregister"
              case .setOnly: return ".SetOnly"
              case .manualAutomatic: return ".ManualAutomatic"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var hasAllowDataRoaming:Bool = false
  public fileprivate(set) var allowDataRoaming:Bool = false

  public fileprivate(set) var operatorSelectMode:NetworkOperatorSettings.OperatorSelectMode = NetworkOperatorSettings.OperatorSelectMode.automatic
  public fileprivate(set) var hasOperatorSelectMode:Bool = false
  public fileprivate(set) var hasNetworkDescriptor:Bool = false
  public fileprivate(set) var networkDescriptor:NetworkOperatorSettings.NetworkDescriptor!
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasAllowDataRoaming {
      try output.writeBool(fieldNumber: 1, value:allowDataRoaming)
    }
    if hasOperatorSelectMode {
      try output.writeEnum(fieldNumber: 2, value:operatorSelectMode.rawValue)
    }
    if hasNetworkDescriptor {
      try output.writeMessage(fieldNumber: 3, value:networkDescriptor)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasAllowDataRoaming {
      serialize_size += allowDataRoaming.computeBoolSize(fieldNumber: 1)
    }
    if (hasOperatorSelectMode) {
      serialize_size += operatorSelectMode.rawValue.computeEnumSize(fieldNumber: 2)
    }
    if hasNetworkDescriptor {
        if let varSizenetworkDescriptor = networkDescriptor?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizenetworkDescriptor
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<NetworkOperatorSettings> {
    var mergedArray = Array<NetworkOperatorSettings>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> NetworkOperatorSettings? {
    return try NetworkOperatorSettings.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> NetworkOperatorSettings.Builder {
    return NetworkOperatorSettings.classBuilder() as! NetworkOperatorSettings.Builder
  }
  public func getBuilder() -> NetworkOperatorSettings.Builder {
    return classBuilder() as! NetworkOperatorSettings.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return NetworkOperatorSettings.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return NetworkOperatorSettings.Builder()
  }
  public func toBuilder() throws -> NetworkOperatorSettings.Builder {
    return try NetworkOperatorSettings.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:NetworkOperatorSettings) throws -> NetworkOperatorSettings.Builder {
    return try NetworkOperatorSettings.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasAllowDataRoaming {
      jsonMap["allowDataRoaming"] = allowDataRoaming as AnyObject?
    }
    if hasOperatorSelectMode {
      jsonMap["operatorSelectMode"] = operatorSelectMode.toString() as AnyObject?
    }
    if hasNetworkDescriptor {
      jsonMap["networkDescriptor"] = try networkDescriptor.encode() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasAllowDataRoaming {
      output += "\(indent) allowDataRoaming: \(allowDataRoaming) \n"
    }
    if (hasOperatorSelectMode) {
      output += "\(indent) operatorSelectMode: \(operatorSelectMode.description)\n"
    }
    if hasNetworkDescriptor {
      output += "\(indent) networkDescriptor {\n"
      if let outDescNetworkDescriptor = networkDescriptor {
        output += try outDescNetworkDescriptor.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasAllowDataRoaming {
             hashCode = (hashCode &* 31) &+ allowDataRoaming.hashValue
          }
          if hasOperatorSelectMode {
             hashCode = (hashCode &* 31) &+ Int(operatorSelectMode.rawValue)
          }
          if hasNetworkDescriptor {
              if let hashValuenetworkDescriptor = networkDescriptor?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkDescriptor
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NetworkOperatorSettings"
  }
  override public func className() -> String {
      return "NetworkOperatorSettings"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return NetworkOperatorSettings.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:NetworkOperatorSettings = NetworkOperatorSettings()
    public func getMessage() -> NetworkOperatorSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasAllowDataRoaming:Bool {
         get {
              return builderResult.hasAllowDataRoaming
         }
    }
    public var allowDataRoaming:Bool {
         get {
              return builderResult.allowDataRoaming
         }
         set (value) {
             builderResult.hasAllowDataRoaming = true
             builderResult.allowDataRoaming = value
         }
    }
    public func setAllowDataRoaming(_ value:Bool) -> NetworkOperatorSettings.Builder {
      self.allowDataRoaming = value
      return self
    }
    public func clearAllowDataRoaming() -> NetworkOperatorSettings.Builder{
         builderResult.hasAllowDataRoaming = false
         builderResult.allowDataRoaming = false
         return self
    }
      public var hasOperatorSelectMode:Bool{
          get {
              return builderResult.hasOperatorSelectMode
          }
      }
      public var operatorSelectMode:NetworkOperatorSettings.OperatorSelectMode {
          get {
              return builderResult.operatorSelectMode
          }
          set (value) {
              builderResult.hasOperatorSelectMode = true
              builderResult.operatorSelectMode = value
          }
      }
      public func setOperatorSelectMode(_ value:NetworkOperatorSettings.OperatorSelectMode) -> NetworkOperatorSettings.Builder {
        self.operatorSelectMode = value
        return self
      }
      public func clearOperatorSelectMode() -> NetworkOperatorSettings.Builder {
         builderResult.hasOperatorSelectMode = false
         builderResult.operatorSelectMode = .automatic
         return self
      }
    public var hasNetworkDescriptor:Bool {
         get {
             return builderResult.hasNetworkDescriptor
         }
    }
    public var networkDescriptor:NetworkOperatorSettings.NetworkDescriptor! {
         get {
             if networkDescriptorBuilder_ != nil {
                builderResult.networkDescriptor = networkDescriptorBuilder_.getMessage()
             }
             return builderResult.networkDescriptor
         }
         set (value) {
             builderResult.hasNetworkDescriptor = true
             builderResult.networkDescriptor = value
         }
    }
    fileprivate var networkDescriptorBuilder_:NetworkOperatorSettings.NetworkDescriptor.Builder! {
         didSet {
            builderResult.hasNetworkDescriptor = true
         }
    }
    public func getNetworkDescriptorBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
      if networkDescriptorBuilder_ == nil {
         networkDescriptorBuilder_ = NetworkOperatorSettings.NetworkDescriptor.Builder()
         builderResult.networkDescriptor = networkDescriptorBuilder_.getMessage()
         if networkDescriptor != nil {
            try! networkDescriptorBuilder_.mergeFrom(networkDescriptor)
         }
      }
      return networkDescriptorBuilder_
    }
    public func setNetworkDescriptor(_ value:NetworkOperatorSettings.NetworkDescriptor!) -> NetworkOperatorSettings.Builder {
      self.networkDescriptor = value
      return self
    }
    public func mergeNetworkDescriptor(_ value:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.Builder {
      if builderResult.hasNetworkDescriptor {
        builderResult.networkDescriptor = try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(builderResult.networkDescriptor).mergeFrom(value).buildPartial()
      } else {
        builderResult.networkDescriptor = value
      }
      builderResult.hasNetworkDescriptor = true
      return self
    }
    public func clearNetworkDescriptor() -> NetworkOperatorSettings.Builder {
      networkDescriptorBuilder_ = nil
      builderResult.hasNetworkDescriptor = false
      builderResult.networkDescriptor = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> NetworkOperatorSettings.Builder {
      builderResult = NetworkOperatorSettings()
      return self
    }
    override public func clone() throws -> NetworkOperatorSettings.Builder {
      return try NetworkOperatorSettings.builderWithPrototype(builderResult)
    }
    override public func build() throws -> NetworkOperatorSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> NetworkOperatorSettings {
      let returnMe:NetworkOperatorSettings = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:NetworkOperatorSettings) throws -> NetworkOperatorSettings.Builder {
      if other == NetworkOperatorSettings() {
       return self
      }
      if other.hasAllowDataRoaming {
           allowDataRoaming = other.allowDataRoaming
      }
      if other.hasOperatorSelectMode {
           operatorSelectMode = other.operatorSelectMode
      }
      if (other.hasNetworkDescriptor) {
          try mergeNetworkDescriptor(other.networkDescriptor)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkOperatorSettings.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          allowDataRoaming = try input.readBool()

        case 16:
          let valueIntoperatorSelectMode = try input.readEnum()
          if let enumsoperatorSelectMode = NetworkOperatorSettings.OperatorSelectMode(rawValue:valueIntoperatorSelectMode){
               operatorSelectMode = enumsoperatorSelectMode
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntoperatorSelectMode))
          }

        case 26:
          let subBuilder:NetworkOperatorSettings.NetworkDescriptor.Builder = NetworkOperatorSettings.NetworkDescriptor.Builder()
          if hasNetworkDescriptor {
            try subBuilder.mergeFrom(networkDescriptor)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkDescriptor = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkOperatorSettings.Builder {
      let resultDecodedBuilder = NetworkOperatorSettings.Builder()
      if let jsonValueAllowDataRoaming = jsonMap["allowDataRoaming"] as? Bool {
        resultDecodedBuilder.allowDataRoaming = jsonValueAllowDataRoaming
      }
      if let jsonValueOperatorSelectMode = jsonMap["operatorSelectMode"] as? String {
        resultDecodedBuilder.operatorSelectMode = try NetworkOperatorSettings.OperatorSelectMode.fromString(jsonValueOperatorSelectMode)
      }
      if let jsonValueNetworkDescriptor = jsonMap["networkDescriptor"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.networkDescriptor = try NetworkOperatorSettings.NetworkDescriptor.Builder.decodeToBuilder(jsonValueNetworkDescriptor).build()

      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> NetworkOperatorSettings.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try NetworkOperatorSettings.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class NetworkDataSettings : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasApn:Bool = false
  public fileprivate(set) var apn:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasApn {
      try output.writeString(fieldNumber: 1, value:apn)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasApn {
      serialize_size += apn.computeStringSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<NetworkDataSettings> {
    var mergedArray = Array<NetworkDataSettings>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> NetworkDataSettings? {
    return try NetworkDataSettings.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> NetworkDataSettings.Builder {
    return NetworkDataSettings.classBuilder() as! NetworkDataSettings.Builder
  }
  public func getBuilder() -> NetworkDataSettings.Builder {
    return classBuilder() as! NetworkDataSettings.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return NetworkDataSettings.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return NetworkDataSettings.Builder()
  }
  public func toBuilder() throws -> NetworkDataSettings.Builder {
    return try NetworkDataSettings.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:NetworkDataSettings) throws -> NetworkDataSettings.Builder {
    return try NetworkDataSettings.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasApn {
      jsonMap["aPN"] = apn as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasApn {
      output += "\(indent) apn: \(apn) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasApn {
             hashCode = (hashCode &* 31) &+ apn.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NetworkDataSettings"
  }
  override public func className() -> String {
      return "NetworkDataSettings"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return NetworkDataSettings.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:NetworkDataSettings = NetworkDataSettings()
    public func getMessage() -> NetworkDataSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasApn:Bool {
         get {
              return builderResult.hasApn
         }
    }
    public var apn:String {
         get {
              return builderResult.apn
         }
         set (value) {
             builderResult.hasApn = true
             builderResult.apn = value
         }
    }
    public func setApn(_ value:String) -> NetworkDataSettings.Builder {
      self.apn = value
      return self
    }
    public func clearApn() -> NetworkDataSettings.Builder{
         builderResult.hasApn = false
         builderResult.apn = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> NetworkDataSettings.Builder {
      builderResult = NetworkDataSettings()
      return self
    }
    override public func clone() throws -> NetworkDataSettings.Builder {
      return try NetworkDataSettings.builderWithPrototype(builderResult)
    }
    override public func build() throws -> NetworkDataSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> NetworkDataSettings {
      let returnMe:NetworkDataSettings = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:NetworkDataSettings) throws -> NetworkDataSettings.Builder {
      if other == NetworkDataSettings() {
       return self
      }
      if other.hasApn {
           apn = other.apn
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> NetworkDataSettings.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          apn = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> NetworkDataSettings.Builder {
      let resultDecodedBuilder = NetworkDataSettings.Builder()
      if let jsonValueApn = jsonMap["aPN"] as? String {
        resultDecodedBuilder.apn = jsonValueApn
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> NetworkDataSettings.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try NetworkDataSettings.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class ServerConnectSettings : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasHost:Bool = false
  public fileprivate(set) var host:String = ""

  public fileprivate(set) var hasPort:Bool = false
  public fileprivate(set) var port:UInt32 = UInt32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasHost {
      try output.writeString(fieldNumber: 1, value:host)
    }
    if hasPort {
      try output.writeUInt32(fieldNumber: 2, value:port)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasHost {
      serialize_size += host.computeStringSize(fieldNumber: 1)
    }
    if hasPort {
      serialize_size += port.computeUInt32Size(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<ServerConnectSettings> {
    var mergedArray = Array<ServerConnectSettings>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> ServerConnectSettings? {
    return try ServerConnectSettings.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ServerConnectSettings.Builder {
    return ServerConnectSettings.classBuilder() as! ServerConnectSettings.Builder
  }
  public func getBuilder() -> ServerConnectSettings.Builder {
    return classBuilder() as! ServerConnectSettings.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return ServerConnectSettings.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return ServerConnectSettings.Builder()
  }
  public func toBuilder() throws -> ServerConnectSettings.Builder {
    return try ServerConnectSettings.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ServerConnectSettings) throws -> ServerConnectSettings.Builder {
    return try ServerConnectSettings.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasHost {
      jsonMap["host"] = host as AnyObject?
    }
    if hasPort {
      jsonMap["port"] = NSNumber(value: port as UInt32)
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasHost {
      output += "\(indent) host: \(host) \n"
    }
    if hasPort {
      output += "\(indent) port: \(port) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasHost {
             hashCode = (hashCode &* 31) &+ host.hashValue
          }
          if hasPort {
             hashCode = (hashCode &* 31) &+ port.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ServerConnectSettings"
  }
  override public func className() -> String {
      return "ServerConnectSettings"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return ServerConnectSettings.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:ServerConnectSettings = ServerConnectSettings()
    public func getMessage() -> ServerConnectSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasHost:Bool {
         get {
              return builderResult.hasHost
         }
    }
    public var host:String {
         get {
              return builderResult.host
         }
         set (value) {
             builderResult.hasHost = true
             builderResult.host = value
         }
    }
    public func setHost(_ value:String) -> ServerConnectSettings.Builder {
      self.host = value
      return self
    }
    public func clearHost() -> ServerConnectSettings.Builder{
         builderResult.hasHost = false
         builderResult.host = ""
         return self
    }
    public var hasPort:Bool {
         get {
              return builderResult.hasPort
         }
    }
    public var port:UInt32 {
         get {
              return builderResult.port
         }
         set (value) {
             builderResult.hasPort = true
             builderResult.port = value
         }
    }
    public func setPort(_ value:UInt32) -> ServerConnectSettings.Builder {
      self.port = value
      return self
    }
    public func clearPort() -> ServerConnectSettings.Builder{
         builderResult.hasPort = false
         builderResult.port = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> ServerConnectSettings.Builder {
      builderResult = ServerConnectSettings()
      return self
    }
    override public func clone() throws -> ServerConnectSettings.Builder {
      return try ServerConnectSettings.builderWithPrototype(builderResult)
    }
    override public func build() throws -> ServerConnectSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ServerConnectSettings {
      let returnMe:ServerConnectSettings = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ServerConnectSettings) throws -> ServerConnectSettings.Builder {
      if other == ServerConnectSettings() {
       return self
      }
      if other.hasHost {
           host = other.host
      }
      if other.hasPort {
           port = other.port
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ServerConnectSettings.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          host = try input.readString()

        case 16:
          port = try input.readUInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> ServerConnectSettings.Builder {
      let resultDecodedBuilder = ServerConnectSettings.Builder()
      if let jsonValueHost = jsonMap["host"] as? String {
        resultDecodedBuilder.host = jsonValueHost
      }
      if let jsonValuePort = jsonMap["port"] as? NSNumber {
        resultDecodedBuilder.port = jsonValuePort.uint32Value
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> ServerConnectSettings.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try ServerConnectSettings.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class ModemConfigurationCommand : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasNetworkOperatorSettings:Bool = false
  public fileprivate(set) var networkOperatorSettings:NetworkOperatorSettings!
  public fileprivate(set) var hasNetworkDataSettings:Bool = false
  public fileprivate(set) var networkDataSettings:NetworkDataSettings!
  public fileprivate(set) var hasServerConnectSettings:Bool = false
  public fileprivate(set) var serverConnectSettings:ServerConnectSettings!
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasNetworkOperatorSettings {
      try output.writeMessage(fieldNumber: 1, value:networkOperatorSettings)
    }
    if hasNetworkDataSettings {
      try output.writeMessage(fieldNumber: 2, value:networkDataSettings)
    }
    if hasServerConnectSettings {
      try output.writeMessage(fieldNumber: 3, value:serverConnectSettings)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasNetworkOperatorSettings {
        if let varSizenetworkOperatorSettings = networkOperatorSettings?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizenetworkOperatorSettings
        }
    }
    if hasNetworkDataSettings {
        if let varSizenetworkDataSettings = networkDataSettings?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizenetworkDataSettings
        }
    }
    if hasServerConnectSettings {
        if let varSizeserverConnectSettings = serverConnectSettings?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizeserverConnectSettings
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<ModemConfigurationCommand> {
    var mergedArray = Array<ModemConfigurationCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> ModemConfigurationCommand? {
    return try ModemConfigurationCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ModemConfigurationCommand.Builder {
    return ModemConfigurationCommand.classBuilder() as! ModemConfigurationCommand.Builder
  }
  public func getBuilder() -> ModemConfigurationCommand.Builder {
    return classBuilder() as! ModemConfigurationCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return ModemConfigurationCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return ModemConfigurationCommand.Builder()
  }
  public func toBuilder() throws -> ModemConfigurationCommand.Builder {
    return try ModemConfigurationCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:ModemConfigurationCommand) throws -> ModemConfigurationCommand.Builder {
    return try ModemConfigurationCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasNetworkOperatorSettings {
      jsonMap["networkOperatorSettings"] = try networkOperatorSettings.encode() as AnyObject?
    }
    if hasNetworkDataSettings {
      jsonMap["networkDataSettings"] = try networkDataSettings.encode() as AnyObject?
    }
    if hasServerConnectSettings {
      jsonMap["serverConnectSettings"] = try serverConnectSettings.encode() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasNetworkOperatorSettings {
      output += "\(indent) networkOperatorSettings {\n"
      if let outDescNetworkOperatorSettings = networkOperatorSettings {
        output += try outDescNetworkOperatorSettings.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNetworkDataSettings {
      output += "\(indent) networkDataSettings {\n"
      if let outDescNetworkDataSettings = networkDataSettings {
        output += try outDescNetworkDataSettings.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasServerConnectSettings {
      output += "\(indent) serverConnectSettings {\n"
      if let outDescServerConnectSettings = serverConnectSettings {
        output += try outDescServerConnectSettings.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasNetworkOperatorSettings {
              if let hashValuenetworkOperatorSettings = networkOperatorSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkOperatorSettings
              }
          }
          if hasNetworkDataSettings {
              if let hashValuenetworkDataSettings = networkDataSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkDataSettings
              }
          }
          if hasServerConnectSettings {
              if let hashValueserverConnectSettings = serverConnectSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueserverConnectSettings
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ModemConfigurationCommand"
  }
  override public func className() -> String {
      return "ModemConfigurationCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return ModemConfigurationCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:ModemConfigurationCommand = ModemConfigurationCommand()
    public func getMessage() -> ModemConfigurationCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasNetworkOperatorSettings:Bool {
         get {
             return builderResult.hasNetworkOperatorSettings
         }
    }
    public var networkOperatorSettings:NetworkOperatorSettings! {
         get {
             if networkOperatorSettingsBuilder_ != nil {
                builderResult.networkOperatorSettings = networkOperatorSettingsBuilder_.getMessage()
             }
             return builderResult.networkOperatorSettings
         }
         set (value) {
             builderResult.hasNetworkOperatorSettings = true
             builderResult.networkOperatorSettings = value
         }
    }
    fileprivate var networkOperatorSettingsBuilder_:NetworkOperatorSettings.Builder! {
         didSet {
            builderResult.hasNetworkOperatorSettings = true
         }
    }
    public func getNetworkOperatorSettingsBuilder() -> NetworkOperatorSettings.Builder {
      if networkOperatorSettingsBuilder_ == nil {
         networkOperatorSettingsBuilder_ = NetworkOperatorSettings.Builder()
         builderResult.networkOperatorSettings = networkOperatorSettingsBuilder_.getMessage()
         if networkOperatorSettings != nil {
            try! networkOperatorSettingsBuilder_.mergeFrom(networkOperatorSettings)
         }
      }
      return networkOperatorSettingsBuilder_
    }
    public func setNetworkOperatorSettings(_ value:NetworkOperatorSettings!) -> ModemConfigurationCommand.Builder {
      self.networkOperatorSettings = value
      return self
    }
    public func mergeNetworkOperatorSettings(_ value:NetworkOperatorSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasNetworkOperatorSettings {
        builderResult.networkOperatorSettings = try NetworkOperatorSettings.builderWithPrototype(builderResult.networkOperatorSettings).mergeFrom(value).buildPartial()
      } else {
        builderResult.networkOperatorSettings = value
      }
      builderResult.hasNetworkOperatorSettings = true
      return self
    }
    public func clearNetworkOperatorSettings() -> ModemConfigurationCommand.Builder {
      networkOperatorSettingsBuilder_ = nil
      builderResult.hasNetworkOperatorSettings = false
      builderResult.networkOperatorSettings = nil
      return self
    }
    public var hasNetworkDataSettings:Bool {
         get {
             return builderResult.hasNetworkDataSettings
         }
    }
    public var networkDataSettings:NetworkDataSettings! {
         get {
             if networkDataSettingsBuilder_ != nil {
                builderResult.networkDataSettings = networkDataSettingsBuilder_.getMessage()
             }
             return builderResult.networkDataSettings
         }
         set (value) {
             builderResult.hasNetworkDataSettings = true
             builderResult.networkDataSettings = value
         }
    }
    fileprivate var networkDataSettingsBuilder_:NetworkDataSettings.Builder! {
         didSet {
            builderResult.hasNetworkDataSettings = true
         }
    }
    public func getNetworkDataSettingsBuilder() -> NetworkDataSettings.Builder {
      if networkDataSettingsBuilder_ == nil {
         networkDataSettingsBuilder_ = NetworkDataSettings.Builder()
         builderResult.networkDataSettings = networkDataSettingsBuilder_.getMessage()
         if networkDataSettings != nil {
            try! networkDataSettingsBuilder_.mergeFrom(networkDataSettings)
         }
      }
      return networkDataSettingsBuilder_
    }
    public func setNetworkDataSettings(_ value:NetworkDataSettings!) -> ModemConfigurationCommand.Builder {
      self.networkDataSettings = value
      return self
    }
    public func mergeNetworkDataSettings(_ value:NetworkDataSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasNetworkDataSettings {
        builderResult.networkDataSettings = try NetworkDataSettings.builderWithPrototype(builderResult.networkDataSettings).mergeFrom(value).buildPartial()
      } else {
        builderResult.networkDataSettings = value
      }
      builderResult.hasNetworkDataSettings = true
      return self
    }
    public func clearNetworkDataSettings() -> ModemConfigurationCommand.Builder {
      networkDataSettingsBuilder_ = nil
      builderResult.hasNetworkDataSettings = false
      builderResult.networkDataSettings = nil
      return self
    }
    public var hasServerConnectSettings:Bool {
         get {
             return builderResult.hasServerConnectSettings
         }
    }
    public var serverConnectSettings:ServerConnectSettings! {
         get {
             if serverConnectSettingsBuilder_ != nil {
                builderResult.serverConnectSettings = serverConnectSettingsBuilder_.getMessage()
             }
             return builderResult.serverConnectSettings
         }
         set (value) {
             builderResult.hasServerConnectSettings = true
             builderResult.serverConnectSettings = value
         }
    }
    fileprivate var serverConnectSettingsBuilder_:ServerConnectSettings.Builder! {
         didSet {
            builderResult.hasServerConnectSettings = true
         }
    }
    public func getServerConnectSettingsBuilder() -> ServerConnectSettings.Builder {
      if serverConnectSettingsBuilder_ == nil {
         serverConnectSettingsBuilder_ = ServerConnectSettings.Builder()
         builderResult.serverConnectSettings = serverConnectSettingsBuilder_.getMessage()
         if serverConnectSettings != nil {
            try! serverConnectSettingsBuilder_.mergeFrom(serverConnectSettings)
         }
      }
      return serverConnectSettingsBuilder_
    }
    public func setServerConnectSettings(_ value:ServerConnectSettings!) -> ModemConfigurationCommand.Builder {
      self.serverConnectSettings = value
      return self
    }
    public func mergeServerConnectSettings(_ value:ServerConnectSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasServerConnectSettings {
        builderResult.serverConnectSettings = try ServerConnectSettings.builderWithPrototype(builderResult.serverConnectSettings).mergeFrom(value).buildPartial()
      } else {
        builderResult.serverConnectSettings = value
      }
      builderResult.hasServerConnectSettings = true
      return self
    }
    public func clearServerConnectSettings() -> ModemConfigurationCommand.Builder {
      serverConnectSettingsBuilder_ = nil
      builderResult.hasServerConnectSettings = false
      builderResult.serverConnectSettings = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> ModemConfigurationCommand.Builder {
      builderResult = ModemConfigurationCommand()
      return self
    }
    override public func clone() throws -> ModemConfigurationCommand.Builder {
      return try ModemConfigurationCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> ModemConfigurationCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ModemConfigurationCommand {
      let returnMe:ModemConfigurationCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:ModemConfigurationCommand) throws -> ModemConfigurationCommand.Builder {
      if other == ModemConfigurationCommand() {
       return self
      }
      if (other.hasNetworkOperatorSettings) {
          try mergeNetworkOperatorSettings(other.networkOperatorSettings)
      }
      if (other.hasNetworkDataSettings) {
          try mergeNetworkDataSettings(other.networkDataSettings)
      }
      if (other.hasServerConnectSettings) {
          try mergeServerConnectSettings(other.serverConnectSettings)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> ModemConfigurationCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:NetworkOperatorSettings.Builder = NetworkOperatorSettings.Builder()
          if hasNetworkOperatorSettings {
            try subBuilder.mergeFrom(networkOperatorSettings)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkOperatorSettings = subBuilder.buildPartial()

        case 18:
          let subBuilder:NetworkDataSettings.Builder = NetworkDataSettings.Builder()
          if hasNetworkDataSettings {
            try subBuilder.mergeFrom(networkDataSettings)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkDataSettings = subBuilder.buildPartial()

        case 26:
          let subBuilder:ServerConnectSettings.Builder = ServerConnectSettings.Builder()
          if hasServerConnectSettings {
            try subBuilder.mergeFrom(serverConnectSettings)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          serverConnectSettings = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> ModemConfigurationCommand.Builder {
      let resultDecodedBuilder = ModemConfigurationCommand.Builder()
      if let jsonValueNetworkOperatorSettings = jsonMap["networkOperatorSettings"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.networkOperatorSettings = try NetworkOperatorSettings.Builder.decodeToBuilder(jsonValueNetworkOperatorSettings).build()

      }
      if let jsonValueNetworkDataSettings = jsonMap["networkDataSettings"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.networkDataSettings = try NetworkDataSettings.Builder.decodeToBuilder(jsonValueNetworkDataSettings).build()

      }
      if let jsonValueServerConnectSettings = jsonMap["serverConnectSettings"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.serverConnectSettings = try ServerConnectSettings.Builder.decodeToBuilder(jsonValueServerConnectSettings).build()

      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> ModemConfigurationCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try ModemConfigurationCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class RtcconfigurationCommand : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasUnixTime:Bool = false
  public fileprivate(set) var unixTime:UInt32 = UInt32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasUnixTime {
      try output.writeUInt32(fieldNumber: 1, value:unixTime)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUnixTime {
      serialize_size += unixTime.computeUInt32Size(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<RtcconfigurationCommand> {
    var mergedArray = Array<RtcconfigurationCommand>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> RtcconfigurationCommand? {
    return try RtcconfigurationCommand.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RtcconfigurationCommand.Builder {
    return RtcconfigurationCommand.classBuilder() as! RtcconfigurationCommand.Builder
  }
  public func getBuilder() -> RtcconfigurationCommand.Builder {
    return classBuilder() as! RtcconfigurationCommand.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return RtcconfigurationCommand.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return RtcconfigurationCommand.Builder()
  }
  public func toBuilder() throws -> RtcconfigurationCommand.Builder {
    return try RtcconfigurationCommand.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:RtcconfigurationCommand) throws -> RtcconfigurationCommand.Builder {
    return try RtcconfigurationCommand.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasUnixTime {
      jsonMap["unixTime"] = NSNumber(value: unixTime as UInt32)
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasUnixTime {
      output += "\(indent) unixTime: \(unixTime) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUnixTime {
             hashCode = (hashCode &* 31) &+ unixTime.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RtcconfigurationCommand"
  }
  override public func className() -> String {
      return "RtcconfigurationCommand"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return RtcconfigurationCommand.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:RtcconfigurationCommand = RtcconfigurationCommand()
    public func getMessage() -> RtcconfigurationCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUnixTime:Bool {
         get {
              return builderResult.hasUnixTime
         }
    }
    public var unixTime:UInt32 {
         get {
              return builderResult.unixTime
         }
         set (value) {
             builderResult.hasUnixTime = true
             builderResult.unixTime = value
         }
    }
    public func setUnixTime(_ value:UInt32) -> RtcconfigurationCommand.Builder {
      self.unixTime = value
      return self
    }
    public func clearUnixTime() -> RtcconfigurationCommand.Builder{
         builderResult.hasUnixTime = false
         builderResult.unixTime = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> RtcconfigurationCommand.Builder {
      builderResult = RtcconfigurationCommand()
      return self
    }
    override public func clone() throws -> RtcconfigurationCommand.Builder {
      return try RtcconfigurationCommand.builderWithPrototype(builderResult)
    }
    override public func build() throws -> RtcconfigurationCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RtcconfigurationCommand {
      let returnMe:RtcconfigurationCommand = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:RtcconfigurationCommand) throws -> RtcconfigurationCommand.Builder {
      if other == RtcconfigurationCommand() {
       return self
      }
      if other.hasUnixTime {
           unixTime = other.unixTime
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> RtcconfigurationCommand.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          unixTime = try input.readUInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> RtcconfigurationCommand.Builder {
      let resultDecodedBuilder = RtcconfigurationCommand.Builder()
      if let jsonValueUnixTime = jsonMap["unixTime"] as? NSNumber {
        resultDecodedBuilder.unixTime = jsonValueUnixTime.uint32Value
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> RtcconfigurationCommand.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try RtcconfigurationCommand.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class CommandResponse : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var types:ControlCommand.Types = ControlCommand.Types.version
  public fileprivate(set) var hasTypes:Bool = false
  public fileprivate(set) var hasMessage_:Bool = false
  public fileprivate(set) var message_:String = ""

  public fileprivate(set) var hasStatus:Bool = false
  public fileprivate(set) var status:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(fieldNumber: 1, value:types.rawValue)
    }
    if hasMessage_ {
      try output.writeString(fieldNumber: 2, value:message_)
    }
    if hasStatus {
      try output.writeBool(fieldNumber: 3, value:status)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasMessage_ {
      serialize_size += message_.computeStringSize(fieldNumber: 2)
    }
    if hasStatus {
      serialize_size += status.computeBoolSize(fieldNumber: 3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<CommandResponse> {
    var mergedArray = Array<CommandResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> CommandResponse? {
    return try CommandResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> CommandResponse.Builder {
    return CommandResponse.classBuilder() as! CommandResponse.Builder
  }
  public func getBuilder() -> CommandResponse.Builder {
    return classBuilder() as! CommandResponse.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return CommandResponse.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return CommandResponse.Builder()
  }
  public func toBuilder() throws -> CommandResponse.Builder {
    return try CommandResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:CommandResponse) throws -> CommandResponse.Builder {
    return try CommandResponse.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasTypes {
      jsonMap["type"] = types.toString() as AnyObject?
    }
    if hasMessage_ {
      jsonMap["message"] = message_ as AnyObject?
    }
    if hasStatus {
      jsonMap["status"] = status as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> CommandResponse {
    return try CommandResponse.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> CommandResponse {
    return try CommandResponse.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasMessage_ {
      output += "\(indent) message_: \(message_) \n"
    }
    if hasStatus {
      output += "\(indent) status: \(status) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasMessage_ {
             hashCode = (hashCode &* 31) &+ message_.hashValue
          }
          if hasStatus {
             hashCode = (hashCode &* 31) &+ status.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CommandResponse"
  }
  override public func className() -> String {
      return "CommandResponse"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return CommandResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:CommandResponse = CommandResponse()
    public func getMessage() -> CommandResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:ControlCommand.Types {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:ControlCommand.Types) -> CommandResponse.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> CommandResponse.Builder {
         builderResult.hasTypes = false
         builderResult.types = .version
         return self
      }
    public var hasMessage_:Bool {
         get {
              return builderResult.hasMessage_
         }
    }
    public var message_:String {
         get {
              return builderResult.message_
         }
         set (value) {
             builderResult.hasMessage_ = true
             builderResult.message_ = value
         }
    }
    public func setMessage_(_ value:String) -> CommandResponse.Builder {
      self.message_ = value
      return self
    }
    public func clearMessage_() -> CommandResponse.Builder{
         builderResult.hasMessage_ = false
         builderResult.message_ = ""
         return self
    }
    public var hasStatus:Bool {
         get {
              return builderResult.hasStatus
         }
    }
    public var status:Bool {
         get {
              return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    public func setStatus(_ value:Bool) -> CommandResponse.Builder {
      self.status = value
      return self
    }
    public func clearStatus() -> CommandResponse.Builder{
         builderResult.hasStatus = false
         builderResult.status = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> CommandResponse.Builder {
      builderResult = CommandResponse()
      return self
    }
    override public func clone() throws -> CommandResponse.Builder {
      return try CommandResponse.builderWithPrototype(builderResult)
    }
    override public func build() throws -> CommandResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CommandResponse {
      let returnMe:CommandResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:CommandResponse) throws -> CommandResponse.Builder {
      if other == CommandResponse() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasMessage_ {
           message_ = other.message_
      }
      if other.hasStatus {
           status = other.status
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> CommandResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = ControlCommand.Types(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttypes))
          }

        case 18:
          message_ = try input.readString()

        case 24:
          status = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> CommandResponse.Builder {
      let resultDecodedBuilder = CommandResponse.Builder()
      if let jsonValueTypes = jsonMap["type"] as? String {
        resultDecodedBuilder.types = try ControlCommand.Types.fromString(jsonValueTypes)
      }
      if let jsonValueMessage_ = jsonMap["message"] as? String {
        resultDecodedBuilder.message_ = jsonValueMessage_
      }
      if let jsonValueStatus = jsonMap["status"] as? Bool {
        resultDecodedBuilder.status = jsonValueStatus
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> CommandResponse.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try CommandResponse.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class DiagnosticRequest : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum DecodedType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case none = 1
      case obd2 = 2
      public func toString() -> String {
        switch self {
        case .none: return "NONE"
        case .obd2: return "OBD2"
        }
      }
      public static func fromString(_ str:String) throws -> DiagnosticRequest.DecodedType {
        switch str {
        case "NONE":  return .none
        case "OBD2":  return .obd2
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .none: return ".None"
              case .obd2: return ".Obd2"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasMessageId:Bool = false
  public fileprivate(set) var messageId:UInt32 = UInt32(0)

  public fileprivate(set) var hasMode:Bool = false
  public fileprivate(set) var mode:UInt32 = UInt32(0)

  public fileprivate(set) var hasPid:Bool = false
  public fileprivate(set) var pid:UInt32 = UInt32(0)

  // TODO we are capping this at 8 bytes for now - need to change when we
  // support multi-frame responses
  public fileprivate(set) var hasPayload:Bool = false
  public fileprivate(set) var payload:Data = Data()

  public fileprivate(set) var hasMultipleResponses:Bool = false
  public fileprivate(set) var multipleResponses:Bool = false

  public fileprivate(set) var hasFrequency:Bool = false
  public fileprivate(set) var frequency:Double = Double(0)

  public fileprivate(set) var hasName:Bool = false
  public fileprivate(set) var name:String = ""

  public fileprivate(set) var decodedType:DiagnosticRequest.DecodedType = DiagnosticRequest.DecodedType.none
  public fileprivate(set) var hasDecodedType:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBus {
      try output.writeInt32(fieldNumber: 1, value:bus)
    }
    if hasMessageId {
      try output.writeUInt32(fieldNumber: 2, value:messageId)
    }
    if hasMode {
      try output.writeUInt32(fieldNumber: 3, value:mode)
    }
    if hasPid {
      try output.writeUInt32(fieldNumber: 4, value:pid)
    }
    if hasPayload {
      try output.writeData(fieldNumber: 5, value:payload)
    }
    if hasMultipleResponses {
      try output.writeBool(fieldNumber: 6, value:multipleResponses)
    }
    if hasFrequency {
      try output.writeDouble(fieldNumber: 7, value:frequency)
    }
    if hasName {
      try output.writeString(fieldNumber: 8, value:name)
    }
    if hasDecodedType {
      try output.writeEnum(fieldNumber: 9, value:decodedType.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasMessageId {
      serialize_size += messageId.computeUInt32Size(fieldNumber: 2)
    }
    if hasMode {
      serialize_size += mode.computeUInt32Size(fieldNumber: 3)
    }
    if hasPid {
      serialize_size += pid.computeUInt32Size(fieldNumber: 4)
    }
    if hasPayload {
      serialize_size += payload.computeDataSize(fieldNumber: 5)
    }
    if hasMultipleResponses {
      serialize_size += multipleResponses.computeBoolSize(fieldNumber: 6)
    }
    if hasFrequency {
      serialize_size += frequency.computeDoubleSize(fieldNumber: 7)
    }
    if hasName {
      serialize_size += name.computeStringSize(fieldNumber: 8)
    }
    if (hasDecodedType) {
      serialize_size += decodedType.rawValue.computeEnumSize(fieldNumber: 9)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<DiagnosticRequest> {
    var mergedArray = Array<DiagnosticRequest>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> DiagnosticRequest? {
    return try DiagnosticRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DiagnosticRequest.Builder {
    return DiagnosticRequest.classBuilder() as! DiagnosticRequest.Builder
  }
  public func getBuilder() -> DiagnosticRequest.Builder {
    return classBuilder() as! DiagnosticRequest.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return DiagnosticRequest.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return DiagnosticRequest.Builder()
  }
  public func toBuilder() throws -> DiagnosticRequest.Builder {
    return try DiagnosticRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DiagnosticRequest) throws -> DiagnosticRequest.Builder {
    return try DiagnosticRequest.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBus {
      jsonMap["bus"] = NSNumber(value: bus as Int32)
    }
    if hasMessageId {
      jsonMap["messageId"] = NSNumber(value: messageId as UInt32)
    }
    if hasMode {
      jsonMap["mode"] = NSNumber(value: mode as UInt32)
    }
    if hasPid {
      jsonMap["pid"] = NSNumber(value: pid as UInt32)
    }
    if hasPayload {
      jsonMap["payload"] = payload.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0)) as AnyObject?
    }
    if hasMultipleResponses {
      jsonMap["multipleResponses"] = multipleResponses as AnyObject?
    }
    if hasFrequency {
      jsonMap["frequency"] = NSNumber(value: frequency as Double)
    }
    if hasName {
      jsonMap["name"] = name as AnyObject?
    }
    if hasDecodedType {
      jsonMap["decodedType"] = decodedType.toString() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasMessageId {
      output += "\(indent) messageId: \(messageId) \n"
    }
    if hasMode {
      output += "\(indent) mode: \(mode) \n"
    }
    if hasPid {
      output += "\(indent) pid: \(pid) \n"
    }
    if hasPayload {
      output += "\(indent) payload: \(payload) \n"
    }
    if hasMultipleResponses {
      output += "\(indent) multipleResponses: \(multipleResponses) \n"
    }
    if hasFrequency {
      output += "\(indent) frequency: \(frequency) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if (hasDecodedType) {
      output += "\(indent) decodedType: \(decodedType.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasMessageId {
             hashCode = (hashCode &* 31) &+ messageId.hashValue
          }
          if hasMode {
             hashCode = (hashCode &* 31) &+ mode.hashValue
          }
          if hasPid {
             hashCode = (hashCode &* 31) &+ pid.hashValue
          }
          if hasPayload {
             hashCode = (hashCode &* 31) &+ payload.hashValue
          }
          if hasMultipleResponses {
             hashCode = (hashCode &* 31) &+ multipleResponses.hashValue
          }
          if hasFrequency {
             hashCode = (hashCode &* 31) &+ frequency.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasDecodedType {
             hashCode = (hashCode &* 31) &+ Int(decodedType.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticRequest"
  }
  override public func className() -> String {
      return "DiagnosticRequest"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return DiagnosticRequest.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:DiagnosticRequest = DiagnosticRequest()
    public func getMessage() -> DiagnosticRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> DiagnosticRequest.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> DiagnosticRequest.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasMessageId:Bool {
         get {
              return builderResult.hasMessageId
         }
    }
    public var messageId:UInt32 {
         get {
              return builderResult.messageId
         }
         set (value) {
             builderResult.hasMessageId = true
             builderResult.messageId = value
         }
    }
    public func setMessageId(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.messageId = value
      return self
    }
    public func clearMessageId() -> DiagnosticRequest.Builder{
         builderResult.hasMessageId = false
         builderResult.messageId = UInt32(0)
         return self
    }
    public var hasMode:Bool {
         get {
              return builderResult.hasMode
         }
    }
    public var mode:UInt32 {
         get {
              return builderResult.mode
         }
         set (value) {
             builderResult.hasMode = true
             builderResult.mode = value
         }
    }
    public func setMode(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.mode = value
      return self
    }
    public func clearMode() -> DiagnosticRequest.Builder{
         builderResult.hasMode = false
         builderResult.mode = UInt32(0)
         return self
    }
    public var hasPid:Bool {
         get {
              return builderResult.hasPid
         }
    }
    public var pid:UInt32 {
         get {
              return builderResult.pid
         }
         set (value) {
             builderResult.hasPid = true
             builderResult.pid = value
         }
    }
    public func setPid(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.pid = value
      return self
    }
    public func clearPid() -> DiagnosticRequest.Builder{
         builderResult.hasPid = false
         builderResult.pid = UInt32(0)
         return self
    }
    public var hasPayload:Bool {
         get {
              return builderResult.hasPayload
         }
    }
    public var payload:Data {
         get {
              return builderResult.payload
         }
         set (value) {
             builderResult.hasPayload = true
             builderResult.payload = value
         }
    }
    public func setPayload(_ value:Data) -> DiagnosticRequest.Builder {
      self.payload = value
      return self
    }
    public func clearPayload() -> DiagnosticRequest.Builder{
         builderResult.hasPayload = false
         builderResult.payload = Data()
         return self
    }
    public var hasMultipleResponses:Bool {
         get {
              return builderResult.hasMultipleResponses
         }
    }
    public var multipleResponses:Bool {
         get {
              return builderResult.multipleResponses
         }
         set (value) {
             builderResult.hasMultipleResponses = true
             builderResult.multipleResponses = value
         }
    }
    public func setMultipleResponses(_ value:Bool) -> DiagnosticRequest.Builder {
      self.multipleResponses = value
      return self
    }
    public func clearMultipleResponses() -> DiagnosticRequest.Builder{
         builderResult.hasMultipleResponses = false
         builderResult.multipleResponses = false
         return self
    }
    public var hasFrequency:Bool {
         get {
              return builderResult.hasFrequency
         }
    }
    public var frequency:Double {
         get {
              return builderResult.frequency
         }
         set (value) {
             builderResult.hasFrequency = true
             builderResult.frequency = value
         }
    }
    public func setFrequency(_ value:Double) -> DiagnosticRequest.Builder {
      self.frequency = value
      return self
    }
    public func clearFrequency() -> DiagnosticRequest.Builder{
         builderResult.hasFrequency = false
         builderResult.frequency = Double(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> DiagnosticRequest.Builder {
      self.name = value
      return self
    }
    public func clearName() -> DiagnosticRequest.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
      public var hasDecodedType:Bool{
          get {
              return builderResult.hasDecodedType
          }
      }
      public var decodedType:DiagnosticRequest.DecodedType {
          get {
              return builderResult.decodedType
          }
          set (value) {
              builderResult.hasDecodedType = true
              builderResult.decodedType = value
          }
      }
      public func setDecodedType(_ value:DiagnosticRequest.DecodedType) -> DiagnosticRequest.Builder {
        self.decodedType = value
        return self
      }
      public func clearDecodedType() -> DiagnosticRequest.Builder {
         builderResult.hasDecodedType = false
         builderResult.decodedType = .none
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> DiagnosticRequest.Builder {
      builderResult = DiagnosticRequest()
      return self
    }
    override public func clone() throws -> DiagnosticRequest.Builder {
      return try DiagnosticRequest.builderWithPrototype(builderResult)
    }
    override public func build() throws -> DiagnosticRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticRequest {
      let returnMe:DiagnosticRequest = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DiagnosticRequest) throws -> DiagnosticRequest.Builder {
      if other == DiagnosticRequest() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasMessageId {
           messageId = other.messageId
      }
      if other.hasMode {
           mode = other.mode
      }
      if other.hasPid {
           pid = other.pid
      }
      if other.hasPayload {
           payload = other.payload
      }
      if other.hasMultipleResponses {
           multipleResponses = other.multipleResponses
      }
      if other.hasFrequency {
           frequency = other.frequency
      }
      if other.hasName {
           name = other.name
      }
      if other.hasDecodedType {
           decodedType = other.decodedType
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DiagnosticRequest.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try input.readInt32()

        case 16:
          messageId = try input.readUInt32()

        case 24:
          mode = try input.readUInt32()

        case 32:
          pid = try input.readUInt32()

        case 42:
          payload = try input.readData()

        case 48:
          multipleResponses = try input.readBool()

        case 57:
          frequency = try input.readDouble()

        case 66:
          name = try input.readString()

        case 72:
          let valueIntdecodedType = try input.readEnum()
          if let enumsdecodedType = DiagnosticRequest.DecodedType(rawValue:valueIntdecodedType){
               decodedType = enumsdecodedType
          } else {
               try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntdecodedType))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticRequest.Builder {
      let resultDecodedBuilder = DiagnosticRequest.Builder()
      if let jsonValueBus = jsonMap["bus"] as? NSNumber {
        resultDecodedBuilder.bus = Int32(jsonValueBus.intValue)
      }
      if let jsonValueMessageId = jsonMap["messageId"] as? NSNumber {
        resultDecodedBuilder.messageId = jsonValueMessageId.uint32Value
      }
      if let jsonValueMode = jsonMap["mode"] as? NSNumber {
        resultDecodedBuilder.mode = jsonValueMode.uint32Value
      }
      if let jsonValuePid = jsonMap["pid"] as? NSNumber {
        resultDecodedBuilder.pid = jsonValuePid.uint32Value
      }
      if let jsonValuePayload = jsonMap["payload"] as? String {
        resultDecodedBuilder.payload = Data(base64EncodedString:jsonValuePayload, options: NSData.Base64DecodingOptions(rawValue:0))!
      }
      if let jsonValueMultipleResponses = jsonMap["multipleResponses"] as? Bool {
        resultDecodedBuilder.multipleResponses = jsonValueMultipleResponses
      }
      if let jsonValueFrequency = jsonMap["frequency"] as? NSNumber {
        resultDecodedBuilder.frequency = jsonValueFrequency.doubleValue
      }
      if let jsonValueName = jsonMap["name"] as? String {
        resultDecodedBuilder.name = jsonValueName
      }
      if let jsonValueDecodedType = jsonMap["decodedType"] as? String {
        resultDecodedBuilder.decodedType = try DiagnosticRequest.DecodedType.fromString(jsonValueDecodedType)
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> DiagnosticRequest.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try DiagnosticRequest.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class DiagnosticResponse : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasMessageId:Bool = false
  public fileprivate(set) var messageId:UInt32 = UInt32(0)

  public fileprivate(set) var hasMode:Bool = false
  public fileprivate(set) var mode:UInt32 = UInt32(0)

  public fileprivate(set) var hasPid:Bool = false
  public fileprivate(set) var pid:UInt32 = UInt32(0)

  public fileprivate(set) var hasSuccess:Bool = false
  public fileprivate(set) var success:Bool = false

  public fileprivate(set) var hasNegativeResponseCode:Bool = false
  public fileprivate(set) var negativeResponseCode:UInt32 = UInt32(0)

  // TODO we are capping this at 8 bytes for now - need to change when we
  // support multi-frame responses
  public fileprivate(set) var hasPayload:Bool = false
  public fileprivate(set) var payload:Data = Data()

  public fileprivate(set) var hasValue:Bool = false
  public fileprivate(set) var value:Double = Double(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasBus {
      try output.writeInt32(1, value:bus)
    }
    if hasMessageId {
      try output.writeUInt32(2, value:messageId)
    }
    if hasMode {
      try output.writeUInt32(3, value:mode)
    }
    if hasPid {
      try output.writeUInt32(4, value:pid)
    }
    if hasSuccess {
      try output.writeBool(5, value:success)
    }
    if hasNegativeResponseCode {
      try output.writeUInt32(6, value:negativeResponseCode)
    }
    if hasPayload {
      try output.writeData(7, value:payload)
    }
    if hasValue {
      try output.writeDouble(8, value:value)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(1)
    }
    if hasMessageId {
      serialize_size += messageId.computeUInt32Size(2)
    }
    if hasMode {
      serialize_size += mode.computeUInt32Size(3)
    }
    if hasPid {
      serialize_size += pid.computeUInt32Size(4)
    }
    if hasSuccess {
      serialize_size += success.computeBoolSize(5)
    }
    if hasNegativeResponseCode {
      serialize_size += negativeResponseCode.computeUInt32Size(6)
    }
    if hasPayload {
      serialize_size += payload.computeDataSize(7)
    }
    if hasValue {
      serialize_size += value.computeDoubleSize(8)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<DiagnosticResponse> {
    var mergedArray = Array<DiagnosticResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> DiagnosticResponse? {
    return try DiagnosticResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DiagnosticResponse.Builder {
    return DiagnosticResponse.classBuilder() as! DiagnosticResponse.Builder
  }
  public func getBuilder() -> DiagnosticResponse.Builder {
    return classBuilder() as! DiagnosticResponse.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return DiagnosticResponse.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return DiagnosticResponse.Builder()
  }
  public func toBuilder() throws -> DiagnosticResponse.Builder {
    return try DiagnosticResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DiagnosticResponse) throws -> DiagnosticResponse.Builder {
    return try DiagnosticResponse.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasBus {
      jsonMap["bus"] = NSNumber(value: bus as Int32)
    }
    if hasMessageId {
      jsonMap["messageId"] = NSNumber(value: messageId as UInt32)
    }
    if hasMode {
      jsonMap["mode"] = NSNumber(value: mode as UInt32)
    }
    if hasPid {
      jsonMap["pid"] = NSNumber(value: pid as UInt32)
    }
    if hasSuccess {
      jsonMap["success"] = success as AnyObject?
    }
    if hasNegativeResponseCode {
      jsonMap["negativeResponseCode"] = NSNumber(value: negativeResponseCode as UInt32)
    }
    if hasPayload {
      jsonMap["payload"] = payload.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0)) as AnyObject?
    }
    if hasValue {
      jsonMap["value"] = NSNumber(value: value as Double)
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder.fromJSONToBuilder(data: data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasMessageId {
      output += "\(indent) messageId: \(messageId) \n"
    }
    if hasMode {
      output += "\(indent) mode: \(mode) \n"
    }
    if hasPid {
      output += "\(indent) pid: \(pid) \n"
    }
    if hasSuccess {
      output += "\(indent) success: \(success) \n"
    }
    if hasNegativeResponseCode {
      output += "\(indent) negativeResponseCode: \(negativeResponseCode) \n"
    }
    if hasPayload {
      output += "\(indent) payload: \(payload) \n"
    }
    if hasValue {
      output += "\(indent) value: \(value) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasMessageId {
             hashCode = (hashCode &* 31) &+ messageId.hashValue
          }
          if hasMode {
             hashCode = (hashCode &* 31) &+ mode.hashValue
          }
          if hasPid {
             hashCode = (hashCode &* 31) &+ pid.hashValue
          }
          if hasSuccess {
             hashCode = (hashCode &* 31) &+ success.hashValue
          }
          if hasNegativeResponseCode {
             hashCode = (hashCode &* 31) &+ negativeResponseCode.hashValue
          }
          if hasPayload {
             hashCode = (hashCode &* 31) &+ payload.hashValue
          }
          if hasValue {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticResponse"
  }
  override public func className() -> String {
      return "DiagnosticResponse"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return DiagnosticResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:DiagnosticResponse = DiagnosticResponse()
    public func getMessage() -> DiagnosticResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> DiagnosticResponse.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> DiagnosticResponse.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasMessageId:Bool {
         get {
              return builderResult.hasMessageId
         }
    }
    public var messageId:UInt32 {
         get {
              return builderResult.messageId
         }
         set (value) {
             builderResult.hasMessageId = true
             builderResult.messageId = value
         }
    }
    public func setMessageId(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.messageId = value
      return self
    }
    public func clearMessageId() -> DiagnosticResponse.Builder{
         builderResult.hasMessageId = false
         builderResult.messageId = UInt32(0)
         return self
    }
    public var hasMode:Bool {
         get {
              return builderResult.hasMode
         }
    }
    public var mode:UInt32 {
         get {
              return builderResult.mode
         }
         set (value) {
             builderResult.hasMode = true
             builderResult.mode = value
         }
    }
    public func setMode(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.mode = value
      return self
    }
    public func clearMode() -> DiagnosticResponse.Builder{
         builderResult.hasMode = false
         builderResult.mode = UInt32(0)
         return self
    }
    public var hasPid:Bool {
         get {
              return builderResult.hasPid
         }
    }
    public var pid:UInt32 {
         get {
              return builderResult.pid
         }
         set (value) {
             builderResult.hasPid = true
             builderResult.pid = value
         }
    }
    public func setPid(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.pid = value
      return self
    }
    public func clearPid() -> DiagnosticResponse.Builder{
         builderResult.hasPid = false
         builderResult.pid = UInt32(0)
         return self
    }
    public var hasSuccess:Bool {
         get {
              return builderResult.hasSuccess
         }
    }
    public var success:Bool {
         get {
              return builderResult.success
         }
         set (value) {
             builderResult.hasSuccess = true
             builderResult.success = value
         }
    }
    public func setSuccess(_ value:Bool) -> DiagnosticResponse.Builder {
      self.success = value
      return self
    }
    public func clearSuccess() -> DiagnosticResponse.Builder{
         builderResult.hasSuccess = false
         builderResult.success = false
         return self
    }
    public var hasNegativeResponseCode:Bool {
         get {
              return builderResult.hasNegativeResponseCode
         }
    }
    public var negativeResponseCode:UInt32 {
         get {
              return builderResult.negativeResponseCode
         }
         set (value) {
             builderResult.hasNegativeResponseCode = true
             builderResult.negativeResponseCode = value
         }
    }
    public func setNegativeResponseCode(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.negativeResponseCode = value
      return self
    }
    public func clearNegativeResponseCode() -> DiagnosticResponse.Builder{
         builderResult.hasNegativeResponseCode = false
         builderResult.negativeResponseCode = UInt32(0)
         return self
    }
    public var hasPayload:Bool {
         get {
              return builderResult.hasPayload
         }
    }
    public var payload:Data {
         get {
              return builderResult.payload
         }
         set (value) {
             builderResult.hasPayload = true
             builderResult.payload = value
         }
    }
    public func setPayload(_ value:Data) -> DiagnosticResponse.Builder {
      self.payload = value
      return self
    }
    public func clearPayload() -> DiagnosticResponse.Builder{
         builderResult.hasPayload = false
         builderResult.payload = Data()
         return self
    }
    public var hasValue:Bool {
         get {
              return builderResult.hasValue
         }
    }
    public var value:Double {
         get {
              return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    public func setValue(_ value:Double) -> DiagnosticResponse.Builder {
      self.value = value
      return self
    }
    public func clearValue() -> DiagnosticResponse.Builder{
         builderResult.hasValue = false
         builderResult.value = Double(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> DiagnosticResponse.Builder {
      builderResult = DiagnosticResponse()
      return self
    }
    override public func clone() throws -> DiagnosticResponse.Builder {
      return try DiagnosticResponse.builderWithPrototype(builderResult)
    }
    override public func build() throws -> DiagnosticResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticResponse {
      let returnMe:DiagnosticResponse = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DiagnosticResponse) throws -> DiagnosticResponse.Builder {
      if other == DiagnosticResponse() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasMessageId {
           messageId = other.messageId
      }
      if other.hasMode {
           mode = other.mode
      }
      if other.hasPid {
           pid = other.pid
      }
      if other.hasSuccess {
           success = other.success
      }
      if other.hasNegativeResponseCode {
           negativeResponseCode = other.negativeResponseCode
      }
      if other.hasPayload {
           payload = other.payload
      }
      if other.hasValue {
           value = other.value
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DiagnosticResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try input.readInt32()

        case 16:
          messageId = try input.readUInt32()

        case 24:
          mode = try input.readUInt32()

        case 32:
          pid = try input.readUInt32()

        case 40:
          success = try input.readBool()

        case 48:
          negativeResponseCode = try input.readUInt32()

        case 58:
          payload = try input.readData()

        case 65:
          value = try input.readDouble()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> DiagnosticResponse.Builder {
      let resultDecodedBuilder = DiagnosticResponse.Builder()
      if let jsonValueBus = jsonMap["bus"] as? NSNumber {
        resultDecodedBuilder.bus = Int32(jsonValueBus.intValue)
      }
      if let jsonValueMessageId = jsonMap["messageId"] as? NSNumber {
        resultDecodedBuilder.messageId = jsonValueMessageId.uint32Value
      }
      if let jsonValueMode = jsonMap["mode"] as? NSNumber {
        resultDecodedBuilder.mode = jsonValueMode.uint32Value
      }
      if let jsonValuePid = jsonMap["pid"] as? NSNumber {
        resultDecodedBuilder.pid = jsonValuePid.uint32Value
      }
      if let jsonValueSuccess = jsonMap["success"] as? Bool {
        resultDecodedBuilder.success = jsonValueSuccess
      }
      if let jsonValueNegativeResponseCode = jsonMap["negativeResponseCode"] as? NSNumber {
        resultDecodedBuilder.negativeResponseCode = jsonValueNegativeResponseCode.uint32Value
      }
      if let jsonValuePayload = jsonMap["payload"] as? String {
        resultDecodedBuilder.payload = Data(base64EncodedString:jsonValuePayload, options: NSData.Base64DecodingOptions(rawValue:0))!
      }
      if let jsonValueValue = jsonMap["value"] as? NSNumber {
        resultDecodedBuilder.value = jsonValueValue.doubleValue
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> DiagnosticResponse.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try DiagnosticResponse.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class DynamicField : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case string_ = 1
      case num = 2
      case bool = 3
      public func toString() -> String {
        switch self {
        case .string_: return "STRING"
        case .num: return "NUM"
        case .bool: return "BOOL"
        }
      }
      public static func fromString(_ str:String) throws -> DynamicField.Types {
        switch str {
        case "STRING":  return .string_
        case "NUM":  return .num
        case "BOOL":  return .bool
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
      }
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      fileprivate func getDescription() -> String { 
          switch self {
              case .string_: return ".String_"
              case .num: return ".Num"
              case .bool: return ".Bool"
          }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var types:DynamicField.Types = DynamicField.Types.string_
  public fileprivate(set) var hasTypes:Bool = false
  public fileprivate(set) var hasStringValue:Bool = false
  public fileprivate(set) var stringValue:String = ""

  public fileprivate(set) var hasNumericValue:Bool = false
  public fileprivate(set) var numericValue:Double = Double(0)

  public fileprivate(set) var hasBooleanValue:Bool = false
  public fileprivate(set) var booleanValue:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    if hasStringValue {
      try output.writeString(2, value:stringValue)
    }
    if hasNumericValue {
      try output.writeDouble(3, value:numericValue)
    }
    if hasBooleanValue {
      try output.writeBool(4, value:booleanValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    if hasStringValue {
      serialize_size += stringValue.computeStringSize(2)
    }
    if hasNumericValue {
      serialize_size += numericValue.computeDoubleSize(3)
    }
    if hasBooleanValue {
      serialize_size += booleanValue.computeBoolSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<DynamicField> {
    var mergedArray = Array<DynamicField>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> DynamicField? {
    return try DynamicField.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> DynamicField.Builder {
    return DynamicField.classBuilder() as! DynamicField.Builder
  }
  public func getBuilder() -> DynamicField.Builder {
    return classBuilder() as! DynamicField.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return DynamicField.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return DynamicField.Builder()
  }
  public func toBuilder() throws -> DynamicField.Builder {
    return try DynamicField.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:DynamicField) throws -> DynamicField.Builder {
    return try DynamicField.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasTypes {
      jsonMap["type"] = types.toString() as AnyObject?
    }
    if hasStringValue {
      jsonMap["stringValue"] = stringValue as AnyObject?
    }
    if hasNumericValue {
      jsonMap["numericValue"] = NSNumber(value: numericValue as Double)
    }
    if hasBooleanValue {
      jsonMap["booleanValue"] = booleanValue as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> DynamicField {
    return try DynamicField.Builder.decodeToBuilder(jsonMap).build()
  }
  class public func fromJSON(_ data:Data) throws -> DynamicField {
    return try DynamicField.Builder.fromJSONToBuilder(data).build()
  }
  public func getDescription(_ indent:String) throws -> String {
    var output = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    if hasStringValue {
      output += "\(indent) stringValue: \(stringValue) \n"
    }
    if hasNumericValue {
      output += "\(indent) numericValue: \(numericValue) \n"
    }
    if hasBooleanValue {
      output += "\(indent) booleanValue: \(booleanValue) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasStringValue {
             hashCode = (hashCode &* 31) &+ stringValue.hashValue
          }
          if hasNumericValue {
             hashCode = (hashCode &* 31) &+ numericValue.hashValue
          }
          if hasBooleanValue {
             hashCode = (hashCode &* 31) &+ booleanValue.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DynamicField"
  }
  override public func className() -> String {
      return "DynamicField"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return DynamicField.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:DynamicField = DynamicField()
    public func getMessage() -> DynamicField {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:DynamicField.Types {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(_ value:DynamicField.Types) -> DynamicField.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> DynamicField.Builder {
         builderResult.hasTypes = false
         builderResult.types = .string_
         return self
      }
    public var hasStringValue:Bool {
         get {
              return builderResult.hasStringValue
         }
    }
    public var stringValue:String {
         get {
              return builderResult.stringValue
         }
         set (value) {
             builderResult.hasStringValue = true
             builderResult.stringValue = value
         }
    }
    public func setStringValue(_ value:String) -> DynamicField.Builder {
      self.stringValue = value
      return self
    }
    public func clearStringValue() -> DynamicField.Builder{
         builderResult.hasStringValue = false
         builderResult.stringValue = ""
         return self
    }
    public var hasNumericValue:Bool {
         get {
              return builderResult.hasNumericValue
         }
    }
    public var numericValue:Double {
         get {
              return builderResult.numericValue
         }
         set (value) {
             builderResult.hasNumericValue = true
             builderResult.numericValue = value
         }
    }
    public func setNumericValue(_ value:Double) -> DynamicField.Builder {
      self.numericValue = value
      return self
    }
    public func clearNumericValue() -> DynamicField.Builder{
         builderResult.hasNumericValue = false
         builderResult.numericValue = Double(0)
         return self
    }
    public var hasBooleanValue:Bool {
         get {
              return builderResult.hasBooleanValue
         }
    }
    public var booleanValue:Bool {
         get {
              return builderResult.booleanValue
         }
         set (value) {
             builderResult.hasBooleanValue = true
             builderResult.booleanValue = value
         }
    }
    public func setBooleanValue(_ value:Bool) -> DynamicField.Builder {
      self.booleanValue = value
      return self
    }
    public func clearBooleanValue() -> DynamicField.Builder{
         builderResult.hasBooleanValue = false
         builderResult.booleanValue = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> DynamicField.Builder {
      builderResult = DynamicField()
      return self
    }
    override public func clone() throws -> DynamicField.Builder {
      return try DynamicField.builderWithPrototype(builderResult)
    }
    override public func build() throws -> DynamicField {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DynamicField {
      let returnMe:DynamicField = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:DynamicField) throws -> DynamicField.Builder {
      if other == DynamicField() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasStringValue {
           stringValue = other.stringValue
      }
      if other.hasNumericValue {
           numericValue = other.numericValue
      }
      if other.hasBooleanValue {
           booleanValue = other.booleanValue
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> DynamicField.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttypes = try input.readEnum()
          if let enumstypes = DynamicField.Types(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttypes))
          }

        case 18:
          stringValue = try input.readString()

        case 25:
          numericValue = try input.readDouble()

        case 32:
          booleanValue = try input.readBool()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> DynamicField.Builder {
      let resultDecodedBuilder = DynamicField.Builder()
      if let jsonValueTypes = jsonMap["type"] as? String {
        resultDecodedBuilder.types = try DynamicField.Types.fromString(jsonValueTypes)
      }
      if let jsonValueStringValue = jsonMap["stringValue"] as? String {
        resultDecodedBuilder.stringValue = jsonValueStringValue
      }
      if let jsonValueNumericValue = jsonMap["numericValue"] as? NSNumber {
        resultDecodedBuilder.numericValue = jsonValueNumericValue.doubleValue
      }
      if let jsonValueBooleanValue = jsonMap["booleanValue"] as? Bool {
        resultDecodedBuilder.booleanValue = jsonValueBooleanValue
      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> DynamicField.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try DynamicField.Builder.decodeToBuilder(jsDataCast)
    }
  }

}

final public class SimpleMessage : GeneratedMessage, GeneratedMessageProtocol {
  public fileprivate(set) var hasName:Bool = false
  public fileprivate(set) var name:String = ""

  public fileprivate(set) var hasValue:Bool = false
  public fileprivate(set) var value:DynamicField!
  public fileprivate(set) var hasEvent:Bool = false
  public fileprivate(set) var event:DynamicField!
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
    if hasName {
      try output.writeString(fieldNumber: 1, value:name)
    }
    if hasValue {
      try output.writeMessage(fieldNumber: 2, value:value)
    }
    if hasEvent {
      try output.writeMessage(fieldNumber: 3, value:event)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasName {
      serialize_size += name.computeStringSize(fieldNumber: 1)
    }
    if hasValue {
        if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizevalue
        }
    }
    if hasEvent {
        if let varSizeevent = event?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizeevent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<SimpleMessage> {
    var mergedArray = Array<SimpleMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> SimpleMessage? {
    return try SimpleMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(_ data:Data) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromData(data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(_ input:InputStream) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SimpleMessage.Builder {
    return SimpleMessage.classBuilder() as! SimpleMessage.Builder
  }
  public func getBuilder() -> SimpleMessage.Builder {
    return classBuilder() as! SimpleMessage.Builder
  }
  public class func classBuilder() -> MessageBuilder {
    return SimpleMessage.Builder()
  }
  public func classBuilder() -> MessageBuilder {
    return SimpleMessage.Builder()
  }
  public func toBuilder() throws -> SimpleMessage.Builder {
    return try SimpleMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(_ prototype:SimpleMessage) throws -> SimpleMessage.Builder {
    return try SimpleMessage.Builder().mergeFrom(prototype)
  }
  public func encode() throws -> Dictionary<String,AnyObject> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
    if hasName {
      jsonMap["name"] = name as AnyObject?
    }
    if hasValue {
      jsonMap["value"] = try value.encode() as AnyObject?
    }
    if hasEvent {
      jsonMap["event"] = try event.encode() as AnyObject?
    }
    return jsonMap
  }
  class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> SimpleMessage {
    return try SimpleMessage.Builder.decodeToBuilder(jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> SimpleMessage {
    return try SimpleMessage.Builder.fromJSONToBuilder(data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasValue {
      output += "\(indent) value {\n"
      if let outDescValue = value {
        output += try outDescValue.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEvent {
      output += "\(indent) event {\n"
      if let outDescEvent = event {
        output += try outDescEvent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasValue {
              if let hashValuevalue = value?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuevalue
              }
          }
          if hasEvent {
              if let hashValueevent = event?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueevent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SimpleMessage"
  }
  override public func className() -> String {
      return "SimpleMessage"
  }
  public func classMetaType() -> GeneratedMessage.Type {
      return SimpleMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:SimpleMessage = SimpleMessage()
    public func getMessage() -> SimpleMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> SimpleMessage.Builder {
      self.name = value
      return self
    }
    public func clearName() -> SimpleMessage.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasValue:Bool {
         get {
             return builderResult.hasValue
         }
    }
    public var value:DynamicField! {
         get {
             if valueBuilder_ != nil {
                builderResult.value = valueBuilder_.getMessage()
             }
             return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    fileprivate var valueBuilder_:DynamicField.Builder! {
         didSet {
            builderResult.hasValue = true
         }
    }
    public func getValueBuilder() -> DynamicField.Builder {
      if valueBuilder_ == nil {
         valueBuilder_ = DynamicField.Builder()
         builderResult.value = valueBuilder_.getMessage()
         if value != nil {
            try! valueBuilder_.mergeFrom(value)
         }
      }
      return valueBuilder_
    }
    public func setValue(_ value:DynamicField!) -> SimpleMessage.Builder {
      self.value = value
      return self
    }
    public func mergeValue(_ value:DynamicField) throws -> SimpleMessage.Builder {
      if builderResult.hasValue {
        builderResult.value = try DynamicField.builderWithPrototype(builderResult.value).mergeFrom(value).buildPartial()
      } else {
        builderResult.value = value
      }
      builderResult.hasValue = true
      return self
    }
    public func clearValue() -> SimpleMessage.Builder {
      valueBuilder_ = nil
      builderResult.hasValue = false
      builderResult.value = nil
      return self
    }
    public var hasEvent:Bool {
         get {
             return builderResult.hasEvent
         }
    }
    public var event:DynamicField! {
         get {
             if eventBuilder_ != nil {
                builderResult.event = eventBuilder_.getMessage()
             }
             return builderResult.event
         }
         set (value) {
             builderResult.hasEvent = true
             builderResult.event = value
         }
    }
    fileprivate var eventBuilder_:DynamicField.Builder! {
         didSet {
            builderResult.hasEvent = true
         }
    }
    public func getEventBuilder() -> DynamicField.Builder {
      if eventBuilder_ == nil {
         eventBuilder_ = DynamicField.Builder()
         builderResult.event = eventBuilder_.getMessage()
         if event != nil {
            try! eventBuilder_.mergeFrom(event)
         }
      }
      return eventBuilder_
    }
    public func setEvent(_ value:DynamicField!) -> SimpleMessage.Builder {
      self.event = value
      return self
    }
    public func mergeEvent(_ value:DynamicField) throws -> SimpleMessage.Builder {
      if builderResult.hasEvent {
        builderResult.event = try DynamicField.builderWithPrototype(builderResult.event).mergeFrom(value).buildPartial()
      } else {
        builderResult.event = value
      }
      builderResult.hasEvent = true
      return self
    }
    public func clearEvent() -> SimpleMessage.Builder {
      eventBuilder_ = nil
      builderResult.hasEvent = false
      builderResult.event = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> SimpleMessage.Builder {
      builderResult = SimpleMessage()
      return self
    }
    override public func clone() throws -> SimpleMessage.Builder {
      return try SimpleMessage.builderWithPrototype(builderResult)
    }
    override public func build() throws -> SimpleMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SimpleMessage {
      let returnMe:SimpleMessage = builderResult
      return returnMe
    }
    public func mergeFrom(_ other:SimpleMessage) throws -> SimpleMessage.Builder {
      if other == SimpleMessage() {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if (other.hasValue) {
          try mergeValue(other.value)
      }
      if (other.hasEvent) {
          try mergeEvent(other.event)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> SimpleMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          name = try input.readString()

        case 18:
          let subBuilder:DynamicField.Builder = DynamicField.Builder()
          if hasValue {
            try subBuilder.mergeFrom(value)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          value = subBuilder.buildPartial()

        case 26:
          let subBuilder:DynamicField.Builder = DynamicField.Builder()
          if hasEvent {
            try subBuilder.mergeFrom(event)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          event = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> SimpleMessage.Builder {
      let resultDecodedBuilder = SimpleMessage.Builder()
      if let jsonValueName = jsonMap["name"] as? String {
        resultDecodedBuilder.name = jsonValueName
      }
      if let jsonValueValue = jsonMap["value"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.value = try DynamicField.Builder.decodeToBuilder(jsonValueValue).build()

      }
      if let jsonValueEvent = jsonMap["event"] as? Dictionary<String,AnyObject> {
        resultDecodedBuilder.event = try DynamicField.Builder.decodeToBuilder(jsonValueEvent).build()

      }
      return resultDecodedBuilder
    }
    class public func fromJSONToBuilder(_ data:Data) throws -> SimpleMessage.Builder {
      let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try SimpleMessage.Builder.decodeToBuilder(jsDataCast)
    }
  }

}


// @@protoc_insertion_point(global_scope)
